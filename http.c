/*
    http.c -- GoAhead HTTP engine

    This module implements an embedded HTTP/1.1 web server. It supports
    loadable URL handlers that define the nature of URL processing performed.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************* Includes ***********************************/

#include    "goahead.h"

/*********************************** Globals **********************************/

WebsStats   websStats;                  /* Web access stats */
int         websDebug;                  /* Run in debug mode and defeat timeouts */

/************************************ Locals **********************************/

static int          listens[WEBS_MAX_LISTEN];   /* Listen endpoints */;
static int          listenMax;

//  MOB - remove webs prefix
static Webs         **webs;                     /* Open connection list head */
static sym_fd_t     websMime;                   /* Set of mime types */
static int          websMax;                    /* List size */

static char_t       websHost[64];               /* Host name for the server */
static char_t       websIpAddr[64];             /* IP address for the server */
static char_t       *websHostUrl = NULL;        /* URL to access server */
static char_t       *websIpAddrUrl = NULL;      /* URL to access server */

/*
    htmExt is declared in this way to avoid a Linux and Solaris segmentation
    fault when a constant string is passed to gstrlower which could change its
    argument.
 */
static char_t  htmExt[] = T(".htm");

#define WEBS_ENCODE_HTML    0x1         /* Bit setting in charMatch[] */

/*
    Character escape/descape matching codes. Generated by charGen.
 */
static uchar charMatch[256] = {
    0x00,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3e,0x3c,0x3c,0x3c,0x3c,0x3c,
    0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,
    0x3c,0x0c,0x3f,0x28,0x2a,0x3c,0x2b,0x0f,0x0e,0x0e,0x0e,0x28,0x28,0x00,0x00,0x28,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x28,0x2a,0x3f,0x28,0x3f,0x2a,
    0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3a,0x3e,0x3a,0x3e,0x00,
    0x3e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3e,0x3e,0x3e,0x02,0x3c,
    0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,
    0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,
    0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,
    0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,
    0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,
    0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,
    0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,
    0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c 
};

/*
    Addd entries to the MimeList as required for your content
    MOB - compare with appweb
 */
static WebsMime websMimeList[] = {
    { T("application/java"), T(".class") },
    { T("application/java"), T(".jar") },
    { T("text/html"), T(".asp") },
    { T("text/html"), T(".htm") },
    { T("text/html"), T(".html") },
    { T("text/xml"), T(".xml") },
    { T("image/gif"), T(".gif") },
    { T("image/jpeg"), T(".jpg") },
    { T("image/png"), T(".png") },
    { T("image/vnd.microsoft.icon"), T(".ico") },
    { T("text/css"), T(".css") },
    { T("text/plain"), T(".txt") },
    { T("application/x-javascript"), T(".js") },
    { T("application/x-shockwave-flash"), T(".swf") },

    { T("application/binary"), T(".exe") },
    { T("application/compress"), T(".z") },
    { T("application/gzip"), T(".gz") },
    { T("application/octet-stream"), T(".bin") },
    { T("application/oda"), T(".oda") },
    { T("application/pdf"), T(".pdf") },
    { T("application/postscript"), T(".ai") },
    { T("application/postscript"), T(".eps") },
    { T("application/postscript"), T(".ps") },
    { T("application/rtf"), T(".rtf") },
    { T("application/x-bcpio"), T(".bcpio") },
    { T("application/x-cpio"), T(".cpio") },
    { T("application/x-csh"), T(".csh") },
    { T("application/x-dvi"), T(".dvi") },
    { T("application/x-gtar"), T(".gtar") },
    { T("application/x-hdf"), T(".hdf") },
    { T("application/x-latex"), T(".latex") },
    { T("application/x-mif"), T(".mif") },
    { T("application/x-netcdf"), T(".nc") },
    { T("application/x-netcdf"), T(".cdf") },
    { T("application/x-ns-proxy-autoconfig"), T(".pac") },
    { T("application/x-patch"), T(".patch") },
    { T("application/x-sh"), T(".sh") },
    { T("application/x-shar"), T(".shar") },
    { T("application/x-sv4cpio"), T(".sv4cpio") },
    { T("application/x-sv4crc"), T(".sv4crc") },
    { T("application/x-tar"), T(".tar") },
    { T("application/x-tgz"), T(".tgz") },
    { T("application/x-tcl"), T(".tcl") },
    { T("application/x-tex"), T(".tex") },
    { T("application/x-texinfo"), T(".texinfo") },
    { T("application/x-texinfo"), T(".texi") },
    { T("application/x-troff"), T(".t") },
    { T("application/x-troff"), T(".tr") },
    { T("application/x-troff"), T(".roff") },
    { T("application/x-troff-man"), T(".man") },
    { T("application/x-troff-me"), T(".me") },
    { T("application/x-troff-ms"), T(".ms") },
    { T("application/x-ustar"), T(".ustar") },
    { T("application/x-wais-source"), T(".src") },
    { T("application/zip"), T(".zip") },
    { T("audio/basic"), T(".au snd") },
    { T("audio/x-aiff"), T(".aif") },
    { T("audio/x-aiff"), T(".aiff") },
    { T("audio/x-aiff"), T(".aifc") },
    { T("audio/x-wav"), T(".wav") },
    { T("audio/x-wav"), T(".ram") },
    { T("image/ief"), T(".ief") },
    { T("image/jpeg"), T(".jpeg") },
    { T("image/jpeg"), T(".jpe") },
    { T("image/tiff"), T(".tiff") },
    { T("image/tiff"), T(".tif") },
    { T("image/x-cmu-raster"), T(".ras") },
    { T("image/x-portable-anymap"), T(".pnm") },
    { T("image/x-portable-bitmap"), T(".pbm") },
    { T("image/x-portable-graymap"), T(".pgm") },
    { T("image/x-portable-pixmap"), T(".ppm") },
    { T("image/x-rgb"), T(".rgb") },
    { T("image/x-xbitmap"), T(".xbm") },
    { T("image/x-xpixmap"), T(".xpm") },
    { T("image/x-xwindowdump"), T(".xwd") },
    { T("text/html"), T(".cfm") },
    { T("text/html"), T(".shtm") },
    { T("text/html"), T(".shtml") },
    { T("text/richtext"), T(".rtx") },
    { T("text/tab-separated-values"), T(".tsv") },
    { T("text/x-setext"), T(".etx") },
    { T("video/mpeg"), T(".mpeg mpg mpe") },
    { T("video/quicktime"), T(".qt") },
    { T("video/quicktime"), T(".mov") },
    { T("video/x-msvideo"), T(".avi") },
    { T("video/x-sgi-movie"), T(".movie") },
    { NULL, NULL},
};

/*
    Standard HTTP error codes
 */
static WebsError websErrors[] = {
    { 200, T("OK") },
    { 204, T("No Content") },
    { 301, T("Redirect") },
    { 302, T("Redirect") },
    { 304, T("Not Modified") },
    { 400, T("Bad Request") },
    { 401, T("Unauthorized") },
    { 403, T("Forbidden") },
    { 404, T("Not Found") },
    { 405, T("Access Denied") },
    { 413, T("Request too large") },
    { 500, T("Internal Server Error") },
    { 501, T("Not Implemented") },
    { 503, T("Service Unavailable") },
    { 0, NULL }
};

//  MOB - should be main.bit
#if BIT_ACCESS_LOG
static char_t   accessLog[64] = T("access.log");    /* Log filename */
static int      accessFd;                           /* Log file handle */
#endif

#if BIT_SESSIONS
static sym_fd_t sessions = -1;
static int      sessionCount = 0;
static int      pruneId;                            /* Callback ID */
#endif

/**************************** Forward Declarations ****************************/

static time_t   getTimeSinceMark(Webs *wp);
static char     *getToken(Webs *wp, char *delim);
static bool     parseFirstLine(Webs *wp);
static bool     parseHeaders(Webs *wp);
static bool     processContent(Webs *wp);
extern bool     parseIncoming(Webs *wp);
extern bool     processParsed(Webs *wp);
static int      setLocalHost();
static void     socketEvent(int sid, int mask, void* data);

//  MOB - rename
static ssize websFlush(Webs *wp); 
static void websReadEvent(Webs *wp);
static void websPump(Webs *wp);

#if BIT_SESSIONS
static void     pruneCache();
#endif
#if BIT_ACCESS_LOG
static void     logRequest(Webs *wp, int code);
#endif
#if BIT_IF_MODIFIED
static time_t   dateParse(time_t tip, char_t *cmd);
#endif

/*********************************** Code *************************************/

int websOpen(char_t *documents, char_t *authPath)
{
    WebsMime    *mt;

    webs = NULL;
    websMax = 0;

#if WINDOWS || VXWORKS
    rand();
#else
    random();
#endif
    traceOpen();
    socketOpen();
    if (setLocalHost() < 0) {
        return -1;
    }
#if BIT_PACK_SSL
    if (websSSLOpen() < 0) {
        return -1;
    }
#endif 
#if BIT_SESSIONS
    if ((sessions = symOpen(WEBS_SMALL_HASH)) < 0) {
        return -1;
    }
    if (!websDebug) {
        pruneId = gschedCallback(WEBS_SESSION_PRUNE, pruneCache, 0);
    }
#endif
    if (documents) {
        websSetDefaultDir(documents);
    }
#if BIT_AUTH
    if (websOpenAuth(authPath) < 0) {
        return -1;
    }
#endif
#if BIT_ROM
    websRomOpen();
#endif
    /*
        Create a mime type lookup table for quickly determining the content type
     */
    websMime = symOpen(WEBS_SYM_INIT * 4);
    gassert(websMime >= 0);
    for (mt = websMimeList; mt->type; mt++) {
        symEnter(websMime, mt->ext, valueString(mt->type, 0), 0);
    }
    if (websUrlHandlerOpen() < 0) {
        return -1;
    }
    websFormOpen();
    websDefaultOpen();

#if BIT_ACCESS_LOG
    if ((accessFd = gopen(accessLog, O_CREAT | O_TRUNC | O_APPEND | O_WRONLY, 0666)) < 0) {
        error(T("Can't open access log %s"), accessLog);
        return -1;
    }
#endif
    return 0;
}


void websClose() 
{
    Webs    *wp;
    int     i;

#if BIT_AUTH
    websCloseAuth();
#endif
#if BIT_SESSIONS
    if (pruneId >= 0) {
        gunschedCallback(pruneId);
        pruneId = -1;
    }
    if (sessions >= 0) {
        symClose(sessions);
        sessions = -1;
    }
#endif
    for (i = 0; i < listenMax; i++) {
        socketCloseConnection(listens[i]);
        listens[i] = -1;
    }
    for (i = listenMax; i >= 0; i--) {
        socketCloseConnection(listens[i]);
    }
    listenMax = 0;
    for (i = websMax; webs && i >= 0; i--) {
        if ((wp = webs[i]) == NULL) {
            continue;
        }
        socketCloseConnection(wp->sid);
        websFree(wp);
    }
    gfree(websHostUrl);
    gfree(websIpAddrUrl);
    websIpAddrUrl = websHostUrl = NULL;

#if BIT_PACK_SSL
    websSSLClose();
#endif
#if BIT_ACCESS_LOG
    if (accessFd >= 0) {
        close(accessFd);
        accessFd = -1;
    }
#endif
#if BIT_ROM
    websRomClose();
#endif
    websDefaultClose();
    symClose(websMime);
    websFormClose();
    websUrlHandlerClose();
    socketClose();
    traceClose();
}


int websListen(char_t *endpoint)
{
    socket_t    *sp;
    char_t      *ip, *ipver;
    int         port, secure, sid;

    if (listenMax >= WEBS_MAX_LISTEN) {
        error(T("Too many listen endpoints"));
        return -1;
    }
    socketParseAddress(endpoint, &ip, &port, &secure, 80);
    if ((sid = socketListen(ip, port, websAccept, 0)) < 0) {
        error(T("Unable to open socket on port %d."), port);
        return -1;
    }
    sp = socketPtr(sid);
    sp->secure = secure;
    listens[listenMax++] = sid;
    ipver = (ip && strchr(ip, ':')) ? "IPv6" : "IPv4";
    if (ip && !gmatch(ip, "::")) {
        trace(0, T("Started %s service on %s:%d, using %s\n"), secure ? "HTTPS" : "HTTP", ip, port, ipver);
    } else {
        trace(0, T("Started %s service on *:%d, using %s\n"), secure ? "HTTPS" : "HTTP", port, ipver);
    }
    gfree(ip);

    if (!websHostUrl) {
        if (port == 80) {
            websHostUrl = gstrdup(ip ? ip : websIpAddr);
        } else {
            gfmtAlloc(&websHostUrl, BIT_LIMIT_URL, T("%s:%d"), ip ? ip : websIpAddr, port);
        }
    }
    if (!websIpAddrUrl) {
        if (port == 80) {
            websIpAddrUrl = gstrdup(websIpAddr);
        } else {
            gfmtAlloc(&websIpAddrUrl, BIT_LIMIT_URL, T("%s:%d"), websIpAddr, port);
        }
    }
    return sid;
}


void websCloseListen(int sid)
{
    int     i;

    if (sid >= 0) {
        socketCloseConnection(sid);
        for (i = 0; i < listenMax; i++) {
            if (listens[i] == sid) {
                for (; i < listenMax; i++) {
                    listens[i] = listens[i+1];
                }
                break;
            }
        }
    }
}


int websAccept(int sid, char *ipaddr, int port, int listenSid)
{
    Webs        *wp;
    int         wid, len;
    char        *cp;
    struct sockaddr_in ifAddr;

    gassert(ipaddr && *ipaddr);
    gassert(sid >= 0);
    gassert(port >= 0);

    /*
        Allocate a new handle for this accepted connection. This will allocate a Webs structure in the webs[] list
     */
    if ((wid = websAlloc(sid)) < 0) {
        return -1;
    }
    wp = webs[wid];
    gassert(wp);
    wp->listenSid = listenSid;

    guni(wp->ipaddr, ipaddr, min(sizeof(wp->ipaddr), strlen(ipaddr) + 1));

    /*
        Get the ip address of the interface that accept the connection.
     */
    len = sizeof(struct sockaddr_in);
    if (getsockname(socketList[sid]->sock, (struct sockaddr*) &ifAddr, (WebsSockLenArg*) &len) < 0) {
        return -1;
    }
    cp = inet_ntoa(ifAddr.sin_addr);
    gstrncpy(wp->ifaddr, cp, gstrlen(cp));
#if VXWORKS
    free(cp);
#endif

    /*
        Check if this is a request from a browser on this system. This is useful to know for permitting administrative
        operations only for local access 
     */
    if (gstrcmp(wp->ipaddr, T("127.0.0.1")) == 0 || gstrcmp(wp->ipaddr, websIpAddr) == 0 || 
            gstrcmp(wp->ipaddr, websHost) == 0) {
        wp->flags |= WEBS_LOCAL_REQUEST;
    }
    /*
        Arrange for socketEvent to be called when read data is available
     */
#if BIT_PACK_SSL
{
    socket_t *lp = socketPtr(listenSid);
    if (lp->secure) {
        wp->flags |= WEBS_SECURE;
    }
    socketCreateHandler(sid, SOCKET_READABLE, (lp->secure) ? websSSLSocketEvent : socketEvent, wp);
}
#else
    socketCreateHandler(sid, SOCKET_READABLE, socketEvent, wp);
#endif

    /*
        Arrange for a timeout to kill hung requests
     */
    wp->timeout = gschedCallback(WEBS_TIMEOUT, websTimeout, (void *) wp);
    trace(8, T("accept request\n"));
    return 0;
}


/*
    The webs socket handler.  Called in response to I/O. We just pass control to the relevant read or write handler. A
    pointer to the webs structure is passed as a (void*) in iwp.  
 */
static void socketEvent(int sid, int mask, void *iwp)
{
    Webs    *wp;

    wp = (Webs*) iwp;
    gassert(wp);

    if (! websValid(wp)) {
        return;
    }
    if (mask & SOCKET_READABLE) {
        websReadEvent(wp);
    } 
    if (mask & SOCKET_WRITABLE) {
        if (websValid(wp) && wp->writable) {
            (*wp->writable)(wp);
        }
    } 
}

//MOB is this used
static bool websEof(Webs *wp)
{
#if BIT_PACK_SSL
    if (wp->flags & WEBS_SECURE) {
        return websSSLEof(wp);
    }
#endif
    return socketEof(wp->sid);
}


static ssize websRead(Webs *wp, char *buf, ssize len)
{
#if BIT_PACK_SSL
    if (wp->flags & WEBS_SECURE) {
        return websSSLRead(wp, buf, len);
    }
#endif
    return socketRead(wp->sid, buf, len);
}


/*
    The webs read handler. This is the primary read event loop. It uses a state machine to track progress while parsing
    the HTTP request.  Note: we never block as the socket is always in non-blocking mode.
 */
static void websReadEvent(Webs *wp)
{
    ringq_t     *ip;
    ssize       nbytes, size, len;

    gassert(wp);
    gassert(websValid(wp));

    websSetTimeMark(wp);
    ip = &wp->input;

    while (websValid(wp)) {
        /* 
            Add one to clen for for a trailing null. Makes parsing much easier 
         */
        size = (!wp->clen || wp->clen > BIT_LIMIT_SOCKET_BUFFER) ? BIT_LIMIT_SOCKET_BUFFER : wp->clen + 1;
        if ((ip->buflen - ringqLen(ip)) < size) {
            ringqGrow(ip);
        }
        nbytes = websRead(wp, (char*) ip->endp, size - 1);
        if (nbytes > 0) {
            ip->endp += nbytes;
            ringqAddNull(ip);
        }
        for (len = ringqLen(ip); len > 0; len = ringqLen(ip)) {
            websPump(wp);
            if (!websValid(wp)) {
                return;
            }
            if (ringqLen(ip) == len) {
                break;
            }
        }
        if (nbytes < 0) {
            if (wp->state == WEBS_BEGIN) {
                /* EOF or error */
                wp->flags &= ~WEBS_KEEP_ALIVE;
                websDone(wp, 0);
            } else {
                /* Request still active. Wait till complete or timer expires */
            }
            break;
        } else if (nbytes == 0 || wp->state != WEBS_CONTENT) {
            break;
        }
    }
}


static void websPump(Webs *wp)
{
    bool    canProceed;

    for (canProceed = 1; canProceed; ) {
        switch (wp->state) {
        case WEBS_BEGIN:
            canProceed = parseIncoming(wp);
            break;
        case WEBS_CONTENT:
            canProceed = processContent(wp);
            break;
        case WEBS_RUNNING:
            websHandleRequest(wp);
            return;
        }
    }
}


bool parseIncoming(Webs *wp)
{
    ringq_t     *ip;
    char_t      *end;

    ip = &wp->input;
    while (*ip->servp == '\r' || *ip->servp == '\n') {
        ringqGetc(ip);
    }
    if ((end = gstrstr((char*) wp->input.servp, "\r\n\r\n")) == 0) {
        if (ringqLen(&wp->input) >= BIT_LIMIT_HEADER) {
            websError(wp, 413, T("Header too large"));
        }
        return 0;
    }
    /*
        Parse the first line of the Http header
     */
    if (!parseFirstLine(wp)) {
        return 0;
    }
    if (!parseHeaders(wp)) {
        return 0;
    }
    wp->state = wp->clen ? WEBS_CONTENT : WEBS_RUNNING;
    return 1;
}


/*
    Parse the first line of a HTTP request
 */
static bool parseFirstLine(Webs *wp)
{
    char_t  *op, *proto, *protoVer, *url, *host, *query, *path, *port, *ext, *buf;
    int     testPort;

    gassert(websValid(wp));

    /*
        Determine the request type: GET, HEAD or POST
     */
    op = getToken(wp, 0);
    if (op == NULL || *op == '\0') {
        websError(wp, 400 | WEBS_CLOSE, T("Bad HTTP request"));
        return 0;
    }
    switch (op[0]) {
    case 'D':
        if (gstrcmp(op, "DELETE") == 0) {
            wp->flags |= WEBS_DELETE_REQUEST;
        }
        break;
    case 'G':
        if (gstrcmp(op, "GET") == 0) {
            wp->flags |= WEBS_GET_REQUEST;
        }
        break;
    case 'H':
        if (gstrcmp(op, "HEAD") == 0) {
            wp->flags |= WEBS_HEAD_REQUEST;
        }
        break;
    case 'P':
        if (gstrcmp(op, "POST") == 0) {
            wp->flags |= WEBS_POST_REQUEST;
        } else if (gstrcmp(op, "PUT") == 0) {
            wp->flags |= WEBS_PUT_REQUEST;
        }
        break;

    default:
        websError(wp, 400 | WEBS_CLOSE, T("Bad request type"));
        return 0;
    }
    wp->method = gstrdup(op);
    websSetVar(wp, T("REQUEST_METHOD"), wp->method);

    url = getToken(wp, 0);
    if (url == NULL || *url == '\0') {
        websError(wp, 400 | WEBS_CLOSE, T("Bad HTTP request"));
        return 0;
    }
    protoVer = getToken(wp, "\r\n");
    trace(2, T("<<< Request\n%s %s %s\n"), wp->method, url, protoVer);

    /*
        Parse the URL and store all the various URL components. websUrlParse returns an allocated buffer in buf which we
        must free. We support both proxied and non-proxied requests. Proxied requests will have http://host/ at the
        start of the URL. Non-proxied will just be local path names.
     */
    host = path = port = proto = query = ext = NULL;
    if (websUrlParse(url, &buf, &host, &path, &port, &query, &proto, NULL, &ext) < 0) {
        websError(wp, 400 | WEBS_CLOSE, T("Bad URL format"));
        return 0;
    }
    if ((wp->path = websNormalizeUriPath(path)) == 0) {
        websError(wp, 400 | WEBS_CLOSE, T("Bad URL format"));
        gfree(buf);
        return 0;
    }
    wp->url = gstrdup(url);
    wp->dir = gstrdup( websGetDefaultDir());
    gfmtAlloc(&wp->lpath, BIT_LIMIT_FILENAME, "%s%s", wp->dir, wp->path);

#if BIT_CGI
    if (gstrstr(url, BIT_CGI_BIN) != NULL) {
        wp->flags |= WEBS_CGI_REQUEST;
        if (wp->flags & WEBS_POST_REQUEST) {
            wp->cgiStdin = websGetCgiCommName();
            if ((wp->cgiFd = gopen(wp->cgiStdin, O_CREAT | O_WRONLY | O_BINARY, 0666)) < 0) {
                websError(wp, 400 | WEBS_CLOSE, T("Can't open CGI file"));
                gfree(buf);
                return 0;
            }
        }
    }
#endif
    wp->query = gstrdup(query);
    wp->host = gstrdup(host);
    wp->protocol = gstrdup(proto);
    wp->protoVersion = gstrdup(protoVer);
    if (gmatch(protoVer, "HTTP/1.1")) {
        wp->flags |= WEBS_KEEP_ALIVE | WEBS_HTTP11;
    } else {
        wp->flags &= ~(WEBS_HTTP11);
#if UNUSED
        if (wp->flags & (WEBS_POST_REQUEST | WEBS_PUT_REQUEST)) {
            wp->clen = MAXINT;
        }
#endif
    }
    if ((testPort = socketGetPort(wp->listenSid)) >= 0) {
        wp->port = testPort;
    } else {
        wp->port = gatoi(port);
    }
    if (gstrcmp(ext, T(".asp")) == 0) {
        wp->flags |= WEBS_JS;
    }
    gfree(buf);
    websUrlType(url, wp->type, TSZ(wp->type));
    return 1;
}


/*
    Parse a full request
 */
static bool parseHeaders(Webs *wp)
{
    char        *ckey, *cvalue;
    char_t      *upperKey, *cp, *key, *value, *tok;
    int         count;

    gassert(websValid(wp));

    trace(2, T("%s"), wp->input.servp);
    websSetVar(wp, T("HTTP_AUTHORIZATION"), T(""));

    /* 
        Parse the header and create the Http header keyword variables
        We rewrite the header as we go for non-local requests.  NOTE: this
        modifies the header string directly and tokenizes each line with '\0'.
    */
    for (count = 0; wp->input.servp[0] != '\r'; count++) {
        if (count >= BIT_LIMIT_NUM_HEADERS) {
            websError(wp, 400 | WEBS_CLOSE, "Too many headers");
            return 0;
        }
        if ((ckey = getToken(wp, ":")) == NULL) {
            continue;
        }
        if ((cvalue = getToken(wp, "\r\n")) == NULL) {
            cvalue = "";
        }
        if (!ckey || !value) {
            websError(wp, 400 | WEBS_CLOSE, "Bad header format");
            return 0;
        }
        key = gallocAscToUni(ckey, strlen(ckey));
        value = gallocAscToUni(cvalue, strlen(cvalue));
        if (!key || !value) {
            websError(wp, 503 | WEBS_CLOSE, T("Insufficient memory"));
            return 0;
        }
        while (gisspace(*value)) {
            value++;
        }
        gstrlower(key);

        /*
            Create a variable (CGI) for each line in the header
         */
        gfmtAlloc(&upperKey, (gstrlen(key) + 6), T("HTTP_%s"), key);
        for (cp = upperKey; *cp; cp++) {
            if (*cp == '-') {
                *cp = '_';
            }
        }
        gstrupper(upperKey);
        websSetVar(wp, upperKey, value);
        gfree(upperKey);

        /*
            Track the requesting agent (browser) type
         */
        if (gstrcmp(key, T("user-agent")) == 0) {
            wp->userAgent = gstrdup(value);

        } else if (gcaselesscmp(key, T("authorization")) == 0) {
            wp->authType = gstrdup(value);
            gtok(wp->authType, " \t", &tok);
            wp->authDetails = gstrdup(tok);

        } else if (gstrcmp(key, T("content-length")) == 0) {
            wp->clen = gatoi(value);
            if (wp->clen > BIT_LIMIT_BODY) {
                websError(wp, 413 | WEBS_CLOSE, T("Too big"));
                return 0;
            }
            if (wp->clen > 0) {
                websSetVar(wp, T("CONTENT_LENGTH"), value);
            } else {
                wp->clen = 0;
            }

        } else if (gstrcmp(key, T("content-type")) == 0) {
            websSetVar(wp, T("CONTENT_TYPE"), value);
            if (strstr(value, "application/x-www-form-urlencoded")) {
                wp->flags |= WEBS_FORM;
            }

#if BIT_KEEP_ALIVE
        } else if (gstrcmp(key, T("connection")) == 0) {
            gstrlower(value);
            if (gstrcmp(value, T("keep-alive")) == 0) {
                wp->flags |= WEBS_KEEP_ALIVE;
            } else if (gstrcmp(value, T("close")) == 0) {
                wp->flags &= ~WEBS_KEEP_ALIVE;
            }
#endif
        } else if (gstrcmp(key, T("cookie")) == 0) {
            wp->flags |= WEBS_COOKIE;
            wp->cookie = gstrdup(value);

#if BIT_IF_MODIFIED
        } else if (gstrcmp(key, T("if-modified-since")) == 0) {
            char_t *cmd;
            time_t tip = 0;

            if ((cp = gstrchr(value, ';')) != NULL) {
                *cp = '\0';
            }

            gfmtAlloc(&cmd, 64, T("%s"), value);

            if ((wp->since = dateParse(tip, cmd)) != 0) {
                wp->flags |= WEBS_IF_MODIFIED;
            }
            gfree(cmd);
#endif /* WEBS_IF_MODIFIED_SUPPORT */
        }
    }
    wp->input.servp += 2;
    wp->remainingContent = wp->clen;
    return 1;
}


static bool processContent(Webs *wp)
{
    ssize   nbytes;

    nbytes = ringqLen(&wp->input);
#if BIT_CGI
    if (wp->flags & WEBS_CGI_REQUEST) {
        gwrite(wp->cgiFd, wp->input.servp, nbytes);
        ringqFlush(&wp->input);
    }
#endif
    wp->remainingContent -= nbytes;
    if (wp->remainingContent <= 0 || (!(wp->flags & WEBS_HTTP11) && websEof(wp))) {
        wp->state = WEBS_RUNNING;
        return 0;
    }
    return 1;
}


/*
    Basic event loop. SocketReady returns true when a socket is ready for service. SocketSelect will block until an
    event occurs. SocketProcess will actually do the servicing.
 */
void websServiceEvents(int *finished)
{
    gassert(finished);
    *finished = 0;
    while (!*finished) {
        if (socketSelect(-1, 3600 * 1000)) {
            socketProcess();
        }
        websCgiCleanup();
        grunCallbacks();
    }
}


/*
    NOTE: the vars variable is modified
 */
static void addFormVars(Webs *wp, char *vars)
{
    char_t  *keyword, *value, *prior, *valNew;

    keyword = gstrtok(vars, T("&"));
    while (keyword != NULL) {
        if ((value = gstrchr(keyword, '=')) != NULL) {
            *value++ = '\0';
            websDecodeUrl(keyword, keyword, gstrlen(keyword));
            websDecodeUrl(value, value, gstrlen(value));
        } else {
            value = T("");
        }
        if (*keyword) {
            /*
                If keyword has already been set, append the new value to what has been stored.
             */
            if ((prior = websGetVar(wp, keyword, NULL)) != 0) {
                gfmtAlloc(&valNew, 256, T("%s %s"), prior, value);
                websSetVar(wp, keyword, valNew);
                gfree(valNew);
            } else {
                websSetVar(wp, keyword, value);
            }
        }
        keyword = gstrtok(NULL, T("&"));
    }
}


/*
    Set the variable (CGI) environment for this request. Create variables for all standard CGI variables. Also decode
    the query string and create a variable for each name=value pair.
 */
void websSetEnv(Webs *wp)
{
    char_t  portBuf[8];
    char_t  *value;

    gassert(websValid(wp));

    websSetVar(wp, T("QUERY_STRING"), wp->query);
    websSetVar(wp, T("GATEWAY_INTERFACE"), T("CGI/1.1"));
    websSetVar(wp, T("SERVER_HOST"), websHost);
    websSetVar(wp, T("SERVER_NAME"), websHost);
    websSetVar(wp, T("SERVER_URL"), websHostUrl);
    websSetVar(wp, T("REMOTE_HOST"), wp->ipaddr);
    websSetVar(wp, T("REMOTE_ADDR"), wp->ipaddr);
    websSetVar(wp, T("PATH_INFO"), wp->path);
    //  MOB - TEST - 
    gstritoa(wp->port, portBuf, sizeof(portBuf));
    websSetVar(wp, T("SERVER_PORT"), portBuf);
    websSetVar(wp, T("SERVER_ADDR"), wp->ifaddr);
    gfmtAlloc(&value, BIT_LIMIT_FILENAME, T("GoAhead/%s"), BIT_VERSION);
    websSetVar(wp, T("SERVER_SOFTWARE"), value);
    gfree(value);
    websSetVar(wp, T("SERVER_PROTOCOL"), wp->protoVersion);

    /*
        Decode and create an environment query variable for each query keyword. We split into pairs at each '&', then
        split pairs at the '='.  Note: we rely on wp->decodedQuery preserving the decoded values in the symbol table.
     */
    if (wp->query && *wp->query) {
        wp->decodedQuery = gstrdup(wp->query);
        addFormVars(wp, wp->decodedQuery);
    }
    if (wp->clen && ringqLen(&wp->input) > 0) {
        if (wp->flags & WEBS_FORM) {
            addFormVars(wp, wp->input.servp);
        }
    }
}


/*
    Define a webs (CGI) variable for this connection. Also create in relevant scripting engines. Note: the incoming
    value may be volatile.  
 */
void websSetVar(Webs *wp, char_t *var, char_t *value)
{
    value_t      v;

    gassert(websValid(wp));

    /*
        value_instring will allocate the string if required.
     */
    if (value) {
        v = valueString(value, VALUE_ALLOCATE);
    } else {
        v = valueString(T(""), VALUE_ALLOCATE);
    }
    symEnter(wp->cgiVars, var, v, 0);
}


/*
 *  Return TRUE if a webs variable exists for this connection.
 */
int websTestVar(Webs *wp, char_t *var)
{
    sym_t       *sp;

    gassert(websValid(wp));

    if (var == NULL || *var == '\0') {
        return 0;
    }
    if ((sp = symLookup(wp->cgiVars, var)) == NULL) {
        return 0;
    }
    return 1;
}


/*
    Get a webs variable but return a default value if string not found.  Note, defaultGetValue can be NULL to permit
    testing existence.  
 */
char_t *websGetVar(Webs *wp, char_t *var, char_t *defaultGetValue)
{
    sym_t   *sp;

    gassert(websValid(wp));
    gassert(var && *var);
 
    if ((sp = symLookup(wp->cgiVars, var)) != NULL) {
        gassert(sp->content.type == string);
        if (sp->content.value.string) {
            return sp->content.value.string;
        } else {
            return T("");
        }
    }
    return defaultGetValue;
}


/*
    Return TRUE if a webs variable is set to a given value
 */
int websCompareVar(Webs *wp, char_t *var, char_t *value)
{
    gassert(websValid(wp));
    gassert(var && *var);
 
    if (gstrcmp(value, websGetVar(wp, var, T(" __UNDEF__ "))) == 0) {
        return 1;
    }
    return 0;
}


/*
    Cancel the request timeout. Note may be called multiple times.
 */
void websTimeoutCancel(Webs *wp)
{
    gassert(websValid(wp));

    if (wp->timeout >= 0) {
        gunschedCallback(wp->timeout);
        wp->timeout = -1;
    }
}


/*
    Output a HTTP response back to the browser. If redirect is set to a 
    URL, the browser will be sent to this location.
 */
void websResponse(Webs *wp, int code, char_t *message, char_t *redirect)
{
    gassert(websValid(wp));

    if ((wp->flags & WEBS_HEAD_REQUEST) == 0 && message && *message) {
        websWriteHeaders(wp, code, glen(message) + 2, redirect);
        websWriteHeader(wp, T("\r\n"));
        websWrite(wp, T("%s\r\n"), message);
    } else {
        websWriteHeaders(wp, code, -1, redirect);
    }
    websDone(wp, code);
}


/*
    Redirect the user to another webs page
 */
void websRedirect(Webs *wp, char_t *url)
{
    char_t  *msgbuf, *urlbuf, *redirectFmt;

    gassert(websValid(wp));
    gassert(url);

    websStats.redirects++;
    msgbuf = urlbuf = NULL;

    /*
        Some browsers require a http://host qualified URL for redirection
     */
    if (gstrstr(url, T("http://")) == NULL) {
        if (*url == '/') {
            url++;
        }
        redirectFmt = T("http://%s/%s");

        if (wp->flags & WEBS_SECURE) {
            redirectFmt = T("https://%s/%s");
        }
        gfmtAlloc(&urlbuf, BIT_LIMIT_URL + 80, redirectFmt, websGetVar(wp, T("HTTP_HOST"), websHostUrl), url);
        url = urlbuf;
    }

    /*
        Add human readable message for completeness. Should not be required.
     */
    gfmtAlloc(&msgbuf, BIT_LIMIT_URL + 80, 
        T("<html><head></head><body>\r\n\
        This document has moved to a new <a href=\"%s\">location</a>.\r\n\
        Please update your documents to reflect the new location.\r\n\
        </body></html>\r\n"), url);

    websResponse(wp, 302, msgbuf, url);
    gfree(msgbuf);
    gfree(urlbuf);
}


/*  
    Escape HTML to escape defined characters (prevent cross-site scripting)
 */
char *websEscapeHtml(cchar *html)
{
    cchar   *ip;
    char    *result, *op;
    int     len;

    if (!html) {
        return gstrdup("");
    }
    for (len = 1, ip = html; *ip; ip++, len++) {
        if (charMatch[(int) (uchar) *ip] & WEBS_ENCODE_HTML) {
            len += 5;
        }
    }
    if ((result = galloc(len)) == 0) {
        return 0;
    }
    /*  
        Leave room for the biggest expansion
     */
    op = result;
    while (*html != '\0') {
        if (charMatch[(uchar) *html] & WEBS_ENCODE_HTML) {
            if (*html == '&') {
                strcpy(op, "&amp;");
                op += 5;
            } else if (*html == '<') {
                strcpy(op, "&lt;");
                op += 4;
            } else if (*html == '>') {
                strcpy(op, "&gt;");
                op += 4;
            } else if (*html == '#') {
                strcpy(op, "&#35;");
                op += 5;
            } else if (*html == '(') {
                strcpy(op, "&#40;");
                op += 5;
            } else if (*html == ')') {
                strcpy(op, "&#41;");
                op += 5;
            } else if (*html == '"') {
                strcpy(op, "&quot;");
                op += 6;
            } else if (*html == '\'') {
                strcpy(op, "&#39;");
                op += 5;
            } else {
                gassert(0);
            }
            html++;
        } else {
            *op++ = *html++;
        }
    }
    gassert(op < &result[len]);
    *op = '\0';
    return result;
}


/*  
    Output an error message and cleanup
 */
void websError(Webs *wp, int code, char_t *fmt, ...)
{
    va_list     args;
    char_t      *msg, *userMsg, *buf;
    char_t      *encoded;

    gassert(websValid(wp));
    gassert(fmt);

    if (code & WEBS_CLOSE) {
        wp->flags &= ~WEBS_KEEP_ALIVE;
        code &= ~WEBS_CLOSE;
    }
    if (wp->remainingContent && code != 200 && code != 301 && code != 302 && code != 401) {
        /* Close connection so we don't have to consume remaining content */
        wp->flags &= ~WEBS_KEEP_ALIVE;
    }
    encoded = websEscapeHtml(wp->url);
    gfree(wp->url);
    wp->url = encoded;

    va_start(args, fmt);
    gfmtValloc(&userMsg, BIT_LIMIT_BUFFER, fmt, args);
    va_end(args);
    error(T("%s"), userMsg);

    encoded = websEscapeHtml(userMsg);
    gfree(userMsg);
    userMsg = encoded;

    msg = T("<html><head><title>Document Error: %s</title></head>\r\n\
        <body><h2>Access Error: %s</h2>\r\n\
        <p>%s</p></body></html>\r\n");
    gfmtAlloc(&buf, BIT_LIMIT_BUFFER, msg, websErrorMsg(code), websErrorMsg(code), userMsg);
    websResponse(wp, code, buf, NULL);
    gfree(buf);
    gfree(userMsg);
    websStats.errors++;
}


/*
    Return the error message for a given code
 */
char_t *websErrorMsg(int code)
{
    WebsError   *ep;

    for (ep = websErrors; ep->code; ep++) {
        if (code == ep->code) {
            return ep->msg;
        }
    }
    return websErrorMsg(500);
}


/*
    Trace a response header
 */
ssize websWriteHeader(Webs *wp, char_t *fmt, ...)
{
    va_list      vargs;
    char_t      *buf;
    ssize        rc;
    
    gassert(websValid(wp));
    va_start(vargs, fmt);
    if (gfmtValloc(&buf, BIT_LIMIT_BUFFER, fmt, vargs) >= BIT_LIMIT_BUFFER) {
        trace(0, T("websWrite lost data, buffer overflow\n"));
    }
    va_end(vargs);
    gassert(buf);
    rc = 0;
    if (buf) {
        if (!(wp->flags & WEBS_RESPONSE_TRACED)) {
            wp->flags |= WEBS_RESPONSE_TRACED;
            trace(2, T(">>> Response\n"));
        }
        trace(2, T("%s"), buf);
        rc = websWriteBlock(wp, buf, gstrlen(buf));
        gfree(buf);
    }
    return rc;
}


/*
    Write a set of headers. Does not write the trailing blank line so callers can add more headers
 */
void websWriteHeaders(Webs *wp, int code, ssize contentLength, char_t *redirect)
{
    char_t      *date;

    gassert(websValid(wp));

    if (!(wp->flags & WEBS_HEADER_DONE)) {
        wp->flags |= WEBS_HEADER_DONE;
        websWriteHeader(wp, T("HTTP/1.0 %d %s\r\n"), code, websErrorMsg(code));
        /*
            The Embedthis Open Source license does not permit modification to the Server header
         */
        websWriteHeader(wp, T("Server: GoAhead/%s\r\n"), BIT_VERSION);

        if ((date = websGetDateString(NULL)) != NULL) {
            websWriteHeader(wp, T("Date: %s\r\n"), date);
            gfree(date);
        }
        /*
            If authentication is required, send the auth header info
         */
        if (wp->authResponse) {
            websWriteHeader(wp, T("WWW-Authenticate: %s\r\n"), wp->authResponse);
        }
        if (contentLength < 0) {
            wp->flags &= ~WEBS_KEEP_ALIVE;
        }
        if (wp->flags & WEBS_KEEP_ALIVE) {
            websWriteHeader(wp, T("Connection: keep-alive\r\n"));
        } else {
            websWriteHeader(wp, T("Connection: close\r\n"));   
        }
        if (wp->flags & (WEBS_JS | WEBS_CGI_REQUEST)) {
            //  MOB - should be set in handlers and not here
            websWriteHeader(wp, T("Pragma: no-cache\r\nCache-Control: no-cache\r\n"));
        }
        if (wp->flags & WEBS_HEAD_REQUEST) {
            websWriteHeader(wp, T("Content-length: %d\r\n"), (int) contentLength);                                           
        } else if (contentLength >= 0) {                                                                                    
            websWriteHeader(wp, T("Content-length: %d\r\n"), (int) contentLength);                                           
            websSetRequestBytes(wp, bytes);                                                                    
        }  
        if (redirect) {
            websWriteHeader(wp, T("Location: %s\r\n"), redirect);
        } else if (wp->type) {
            websWriteHeader(wp, T("Content-type: %s\r\n"), wp->type);
        }
        if (wp->responseCookie) {
            websWriteHeader(wp, T("Set-Cookie: %s\r\n"), wp->responseCookie);
            websWriteHeader(wp, T("Cache-control: %s\r\n"), "no-cache=\"set-cookie\"");
        }
    }
}


/*
    Do formatted output to the browser. This is the public Javascript and form write procedure.
 */
ssize websWrite(Webs *wp, char_t *fmt, ...)
{
    va_list      vargs;
    char_t      *buf;
    ssize        rc;
    
    gassert(websValid(wp));

    va_start(vargs, fmt);

    buf = NULL;
    rc = 0;
    if (gfmtValloc(&buf, BIT_LIMIT_BUFFER, fmt, vargs) >= BIT_LIMIT_BUFFER) {
        trace(0, T("websWrite lost data, buffer overflow\n"));
    }
    va_end(vargs);
    gassert(buf);
    if (buf) {
        rc = websWriteBlock(wp, buf, gstrlen(buf));
        gfree(buf);
    }
    return rc;
}


static ssize bufferOutput(Webs *wp, char *buf, ssize size) 
{
    ringq_t     *op;
    ssize       sofar, thisWrite, len, room;

    op = &wp->output;
    while (size > 0) {
        len = ringqLen(op);
        room = op->buflen - len;
        if (len > 0 && room < size) {
            if (websFlush(wp) > 0) {
                continue;
            }
            if (op->buflen < op->maxsize) {
                ringqGrow(op);
                continue;
            }
        }
        if (room == 0) {
            break;
        }
        thisWrite = min(room, size);
        ringqPutBlk(op, buf, thisWrite);
        size -= thisWrite;
        buf += thisWrite;
        sofar += thisWrite;
    }
    return sofar;
}


/*
    Write a block of data of length "size" to the user's browser. Public write block procedure.  If unicode 
    is turned on this function expects buf to be a unicode string and it converts it to ASCII before writing. See
    websWriteDataNonBlock to always write binary or ASCII data with no unicode conversion.  This returns the number of
    char_t's processed.  It spins until all the data is absorbed.
 */
//  MOB - review API websWriteUni()
ssize websWriteBlock(Webs *wp, char_t *buf, ssize size)
{
    char    *asciiBuf, *cp;
    ssize   len, written;

    gassert(wp);
    gassert(websValid(wp));
    gassert(buf);
    gassert(size >= 0);

    written = len = 0;
    cp = asciiBuf = gallocUniToAsc(buf, size);

    //  MOB - WARNING: spins
    while (size > 0) {  
        if ((len = bufferOutput(wp, cp, size)) < 0) {
            gfree(asciiBuf);
            return -1;
        }
        size -= len;
        cp += len;
        written += len;
    }
    gfree(asciiBuf);
    return written;
}


static ssize writeToSocket(Webs *wp, char *buf, ssize size)
{
    ssize   written;

#if BIT_PACK_SSL
    if (wp->flags & WEBS_SECURE) {
        if ((written = websSSLWrite(wp, buf, size)) < 0) {
            return -1;
        }
        websSSLFlush(wp);
    } else 
#endif
    if ((written = socketWrite(wp->sid, buf, size)) < 0) {
        return -1;
    }
    return written;
}


static ssize websFlush(Webs *wp) 
{
    ringq_t     *op;
    ssize       written, size;

    op = &wp->output;
    size = ringqLen(&wp->output);
    written = 0;

    if (size > 0 && ((written = writeToSocket(wp, (char*) op->servp, size))) > 0) {
        ringqGetBlkAdj(op, written);
        ringqCompact(op);
    }
    return written;
}


/*
    Write a block of data of length "size" to the user's browser. Same as websWriteBlock except that it expects
    straight ASCII or binary and does no unicode conversion before writing the data.  If the socket cannot hold all the
    data, it will return the number of bytes flushed to the socket before it would have blocked.  This returns the
    number of chars processed or -1 if socketWrite fails.
 */
//  MOB - review API
ssize websWriteDataNonBlock(Webs *wp, char *buf, ssize size)
{
    ssize   written;
    
    if ((written = websFlush(wp)) < 0) {
        return written;
    }
    return writeToSocket(wp, buf, size);
}


/*
    Decode a URL (or part thereof). Allows insitu decoding.
 */
void websDecodeUrl(char_t *decoded, char_t *token, ssize len)
{
    char_t  *ip,  *op;
    int     num, i, c;
    
    gassert(decoded);
    gassert(token);

    op = decoded;
    for (ip = token; *ip && len > 0; ip++, op++) {
        if (*ip == '+') {
            *op = ' ';
        } else if (*ip == '%' && gisxdigit(ip[1]) && gisxdigit(ip[2])) {
            /*
                Convert %nn to a single character
             */
            ip++;
            for (i = 0, num = 0; i < 2; i++, ip++) {
                c = tolower(*ip);
                if (c >= 'a' && c <= 'f') {
                    num = (num * 16) + 10 + c - 'a';
                } else {
                    num = (num * 16) + c - '0';
                }
            }
            *op = (char_t) num;
            ip--;

        } else {
            *op = *ip;
        }
        len--;
    }
    *op = '\0';
}


#if BIT_ACCESS_LOG
/*
    Output a log message in Common Log Format: See http://httpd.apache.org/docs/1.3/logs.html#common
 */
static void logRequest(Webs *wp, int code)
{
    char_t      *buf, timeStr[28], zoneStr[6], dataStr[16];
    char        *abuf;
    ssize       len;
    time_t      timer;
    struct tm   localt;
#if WINDOWS
    DWORD       dwRet;
    TIME_ZONE_INFORMATION tzi;
#endif

    time(&timer);
#if WINDOWS
    localtime_s(&localt, &timer);
#else
    localtime_r(&timer, &localt);
#endif
    strftime(timeStr, sizeof(timeStr), "%d/%b/%Y:%H:%M:%S", &localt); 
    timeStr[sizeof(timeStr) - 1] = '\0';
#if WINDOWS
    dwRet = GetTimeZoneInformation(&tzi);
    gfmtStatic(zoneStr, sizeof(zoneStr), "%+03d00", -(int)(tzi.Bias/60));
#elif !VXWORKS
    gfmtStatic(zoneStr, sizeof(zoneStr), "%+03d00", (int)(localt.tm_gmtoff/3600));
#else
    zoneStr[0] = '\0';
#endif
    zoneStr[sizeof(zoneStr) - 1] = '\0';
    if (wp->written != 0) {
        gfmtStatic(dataStr, sizeof(dataStr), "%d", (int) wp->written);
        dataStr[sizeof(dataStr) - 1] = '\0';
    } else {
        dataStr[0] = '-'; dataStr[1] = '\0';
    }
    buf = NULL;
    gfmtAlloc(&buf, BIT_LIMIT_URL + 80, 
        T("%s - %s [%s %s] \"%s %s %s\" %d %s\n"), 
        wp->ipaddr,
        wp->username == NULL ? "-" : wp->username,
        timeStr, zoneStr,
        wp->flags & WEBS_POST_REQUEST ? "POST" : (wp->flags & WEBS_HEAD_REQUEST ? "HEAD" : "GET"), wp->path,
        wp->protoVersion, code, dataStr);
    len = gstrlen(buf);
    abuf = gallocUniToAsc(buf, len+1);
    write(accessFd, abuf, len);
    gfree(buf);
    gfree(abuf);
}
#endif


/*
    Request timeout. The timeout triggers if we have not read any data from the users browser in the last WEBS_TIMEOUT
    period. If we have heard from the browser, simply re-issue the timeout.
 */
void websTimeout(void *arg, int id)
{
    Webs        *wp;
    time_t      tm, delay;

    wp = (Webs*) arg;
    gassert(websValid(wp));

    tm = getTimeSinceMark(wp) * 1000;
    if (websDebug) {
        greschedCallback(id, (int) WEBS_TIMEOUT);
        return;
    } else if (tm >= WEBS_TIMEOUT) {
        websStats.timeouts++;
        gunschedCallback(id);
        wp->timeout = -1;
        websDone(wp, 404);
    } else {
        delay = WEBS_TIMEOUT - tm;
        gassert(delay > 0);
        greschedCallback(id, (int) delay);
    }
}


/*
    Called when the request is complete.
 */
void websDone(Webs *wp, int code)
{
    gassert(websValid(wp));

    wp->code = code & ~WEBS_CLOSE;
    socketDeleteHandler(wp->sid);
#if BIT_ACCESS_LOG
    logRequest(wp, code);
#endif
    websPageClose(wp);

#if BIT_PACK_SSL
    if (wp->flags & WEBS_SECURE) {
        websTimeoutCancel(wp);
        websSSLFlush(wp);
        //  MOB - why close connection. Why not keep-alive?
        socketCloseConnection(wp->sid);
        websFree(wp);
        return;
    }
#endif
#if BIT_CGI
    if (wp->cgiFd > 0) {
        gclose(wp->cgiFd);
    }
#endif
    if (wp->flags & WEBS_KEEP_ALIVE && wp->remainingContent == 0) {
        websFlush(wp);
        wp->state = WEBS_BEGIN;
        wp->flags &= (WEBS_KEEP_ALIVE | WEBS_SECURE | WEBS_HTTP11);
        if (wp->clen) {
            ringqGetBlkAdj(&wp->input, wp->clen);
        }
        wp->clen = 0;
        ringqCompact(&wp->input);
        socketCreateHandler(wp->sid, SOCKET_READABLE, socketEvent, wp);
        if (ringqLen(&wp->input)) {
            socketReservice(wp->sid);
        }
        websTimeoutCancel(wp);
        wp->timeout = gschedCallback(WEBS_TIMEOUT, websTimeout, (void *) wp);
        return;
    }
    websTimeoutCancel(wp);
    socketSetBlock(wp->sid, 1);
    websFlush(wp);
    socketCloseConnection(wp->sid);
    websFree(wp);
}


int websAlloc(int sid)
{
    Webs        *wp;
    int         wid;

    //  MOB - warning. This structue is not being zeroed or initialized.
    if ((wid = gallocEntry((void***) &webs, &websMax, sizeof(Webs))) < 0) {
        return -1;
    }
    wp = webs[wid];
    memset(wp, 0, sizeof(Webs));
    wp->wid = wid;
    wp->sid = sid;
    wp->state = WEBS_BEGIN;
    wp->docfd = -1;
    wp->timeout = -1;
    wp->session = 0;
    gassert(wp->flags == 0);
    ringqOpen(&wp->input, BIT_LIMIT_HEADERS, BIT_LIMIT_HEADERS + BIT_LIMIT_BODY);
    ringqOpen(&wp->output, BIT_LIMIT_RESPONSE_BUFFER, BIT_LIMIT_RESPONSE_BUFFER);

    /*
        Create storage for the CGI variables. We supply the symbol tables for both the CGI variables and for the global
        functions. The function table is common to all webs instances (ie. all browsers)
     */
    wp->cgiVars = symOpen(WEBS_SYM_INIT);
    wp->cgiFd = 0;
    return wid;
}


void websFree(Webs *wp)
{
    gassert(websValid(wp));

    //  MOB - OPT reduce allocations
    gfree(wp->path);
    gfree(wp->url);
    gfree(wp->host);
    gfree(wp->lpath);
    gfree(wp->query);
    gfree(wp->decodedQuery);
    gfree(wp->authType);
    gfree(wp->password);
    gfree(wp->username);
    gfree(wp->cookie);
    gfree(wp->responseCookie);
    gfree(wp->userAgent);
    gfree(wp->dir);
    gfree(wp->protocol);
    gfree(wp->protoVersion);
    gfree(wp->cgiStdin);
    gfree(wp->method);

#if BIT_AUTH
    gfree(wp->authDetails);
    gfree(wp->realm);
#if BIT_DIGEST_AUTH
    //  MOB - is URI just for AUTH?
    gfree(wp->digestUri);
    gfree(wp->opaque);
    gfree(wp->nonce);
    gfree(wp->nc);
    gfree(wp->cnonce);
    gfree(wp->qop);
#endif
#endif
#if BIT_PACK_SSL
    websSSLFree(wp);
#endif
    symClose(wp->cgiVars);

    ringqClose(&wp->input);
    ringqClose(&wp->output);
    websMax = gfreeHandle((void***) &webs, wp->wid);
    gfree(wp);
    gassert(websMax >= 0);
}


char_t *websGetHost()
{
    return websHost;
}


char_t *websGetIpAddrUrl()
{
    return websIpAddrUrl;
}


char_t *websGetHostUrl()
{
    return websHostUrl;
}


ssize websGetRequestBytes(Webs *wp)
{
    gassert(websValid(wp));
    return wp->numbytes;
}


char_t *websGetRequestDir(Webs *wp)
{
    gassert(websValid(wp));

    if (wp->dir == NULL) {
        return T("");
    }
    return wp->dir;
}


int websGetRequestFlags(Webs *wp)
{
    gassert(websValid(wp));

    return wp->flags;
}


char_t *websGetRequestIpAddr(Webs *wp)
{
    gassert(websValid(wp));

    return wp->ipaddr;
}


char_t *websGetRequestLpath(Webs *wp)
{
    gassert(websValid(wp));

    //  MOB - unify
#if BIT_ROM
    return wp->path;
#else
    return wp->lpath;
#endif
}


char_t *websGetRequestPath(Webs *wp)
{
    gassert(websValid(wp));

    if (wp->path == NULL) {
        return T("");
    }
    return wp->path;
}


char_t *websGetRequestPassword(Webs *wp)
{
    gassert(websValid(wp));
    return wp->password;
}


char_t *websGetRequestType(Webs *wp)
{
    gassert(websValid(wp));
    return wp->type;
}


char_t *websGetRequestUserName(Webs *wp)
{
    gassert(websValid(wp));
    return wp->username;
}


ssize websGetRequestWritten(Webs *wp)
{
    gassert(websValid(wp));

    return wp->written;
}


static int setLocalHost()
{
    struct in_addr  intaddr;
    char            host[128], *cp;
    char_t          wbuf[128];

    if (gethostname(host, sizeof(host)) < 0) {
        error(T("Can't get hostname"));
        return -1;
    }
#if VXWORKS
    intaddr.s_addr = (ulong) hostGetByName(host);
    cp = inet_ntoa(intaddr);
    //  MOB - OPT so don't copy if not unicode
    guni(wbuf, cp, min(strlen(cp) + 1, sizeof(wbuf)));
    free(cp);
#elif ECOS
    cp = inet_ntoa(eth0_bootp_data.bp_yiaddr);
    //  MOB - OPT so don't copy if not unicode
    guni(wbuf, cp, min(strlen(cp) + 1, sizeof(wbuf)));
#else
{
    struct hostent  *hp;
    if ((hp = gethostbyname(host)) == NULL) {
        error(T("Can't get host address"));
        return -1;
    }
    memcpy((char *) &intaddr, (char *) hp->h_addr_list[0], (size_t) hp->h_length);
    cp = inet_ntoa(intaddr);
    //  MOB - OPT so don't copy if not unicode
    guni(wbuf, cp, min(strlen(cp) + 1, sizeof(wbuf)));
}
#endif
    websSetIpAddr(wbuf);
    websSetHost(wbuf);
    return 0;
}


void websSetHost(char_t *host)
{
    gstrncpy(websHost, host, TSZ(websHost));
}


void websSetHostUrl(char_t *url)
{
    gassert(url && *url);

    gfree(websHostUrl);
    websHostUrl = gstrdup(url);
}


void websSetIpAddr(char_t *ipaddr)
{
    gassert(ipaddr && *ipaddr);
    gstrncpy(websIpAddr, ipaddr, TSZ(websIpAddr));
}


void websSetRequestBytes(Webs *wp, ssize bytes)
{
    gassert(websValid(wp));
    gassert(bytes >= 0);
    wp->numbytes = bytes;
}


void websSetRequestLpath(Webs *wp, char_t *lpath)
{
    gassert(websValid(wp));
    gassert(lpath && *lpath);

    if (wp->lpath) {
        gfree(wp->lpath);
    }
    wp->lpath = gstrdup(lpath);
    websSetVar(wp, T("PATH_TRANSLATED"), wp->lpath);
}


/*
    Update the URL path and the directory containing the web page
 */
void websSetRequestPath(Webs *wp, char_t *dir, char_t *path)
{
    char_t  *tmp;

    gassert(websValid(wp));

    if (dir) { 
        tmp = wp->dir;
        wp->dir = gstrdup(dir);
        if (tmp) {
            gfree(tmp);
        }
    }
    if (path) {
        tmp = wp->path;
        wp->path = gstrdup(path);
        websSetVar(wp, T("PATH_INFO"), wp->path);
        if (tmp) {
            gfree(tmp);
        }
    }
}


void websRewriteRequest(Webs *wp, char_t *url)
{
    gfree(wp->url);
    wp->url = gstrdup(url);
    websSetRequestPath(wp, NULL, wp->url);
    gfree(wp->lpath);
    gfmtAlloc(&wp->lpath, BIT_LIMIT_FILENAME, "%s%s", wp->dir, wp->path);
}


void websSetRequestWritten(Webs *wp, ssize written)
{
    gassert(websValid(wp));
    wp->written = written;
}


int websValid(Webs *wp)
{
    int     wid;

    for (wid = 0; wid < websMax; wid++) {
        if (wp == webs[wid]) {
            return 1;
        }
    }
    return 0;
}


/*
    Build an ASCII time string.  If sbuf is NULL we use the current time, else we use the last modified time of sbuf;
 */
char_t *websGetDateString(WebsFileInfo *sbuf)
{
    char_t  *cp, *r;
    time_t  now;

    if (sbuf == NULL) {
        time(&now);
    } else {
        now = sbuf->mtime;
    }
    if ((cp = gctime(&now)) != NULL) {
        cp[gstrlen(cp) - 1] = '\0';
        r = gstrdup(cp);
        return r;
    }
    return NULL;
}


/*
    Mark time. Set a timestamp so that, later, we can return the number of seconds since we made the mark. Note that the
    mark my not be a "real" time, but rather a relative marker.
 */
void websSetTimeMark(Webs *wp)
{
    wp->timestamp = time(0);
}


/*
    Get the number of seconds since the last mark.
 */
static time_t getTimeSinceMark(Webs *wp)
{
    return time(0) - wp->timestamp;
}


#if BIT_IF_MODIFIED
//  MOB - move all into a date.c
/*  
    These functions are intended to closely mirror the syntax for HTTP-date 
    from RFC 2616 (HTTP/1.1 spec).  This code was submitted by Pete Bergstrom.
    
    RFC1123Date = wkday "," SP date1 SP time SP "GMT"
    RFC850Date  = weekday "," SP date2 SP time SP "GMT"
    ASCTimeDate = wkday SP date3 SP time SP 4DIGIT
  
    Each of these functions tries to parse the value and update the index to 
    the point it leaves off parsing.
 */

typedef enum { JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC } MonthEnumeration;
typedef enum { SUN, MON, TUE, WED, THU, FRI, SAT } WeekdayEnumeration;

/*  
    Parse an N-digit value
 */

static int parseNDIGIT(char_t *buf, int digits, int *index) 
{
    int tmpIndex, returnValue;

    returnValue = 0;
    for (tmpIndex = *index; tmpIndex < *index+digits; tmpIndex++) {
        if (gisdigit(buf[tmpIndex])) {
            returnValue = returnValue * 10 + (buf[tmpIndex] - T('0'));
        }
    }
    *index = tmpIndex;
    return returnValue;
}


/*
    Return an index into the month array
 */

static int parseMonth(char_t *buf, int *index) 
{
    /*  
        "Jan" | "Feb" | "Mar" | "Apr" | "May" | "Jun" | 
        "Jul" | "Aug" | "Sep" | "Oct" | "Nov" | "Dec"
     */
    int tmpIndex, returnValue;
    returnValue = -1;
    tmpIndex = *index;

    switch (buf[tmpIndex]) {
        case 'A':
            switch (buf[tmpIndex+1]) {
                case 'p':
                    returnValue = APR;
                    break;
                case 'u':
                    returnValue = AUG;
                    break;
            }
            break;
        case 'D':
            returnValue = DEC;
            break;
        case 'F':
            returnValue = FEB;
            break;
        case 'J':
            switch (buf[tmpIndex+1]) {
                case 'a':
                    returnValue = JAN;
                    break;
                case 'u':
                    switch (buf[tmpIndex+2]) {
                        case 'l':
                            returnValue = JUL;
                            break;
                        case 'n':
                            returnValue = JUN;
                            break;
                    }
                    break;
            }
            break;
        case 'M':
            switch (buf[tmpIndex+1]) {
                case 'a':
                    switch (buf[tmpIndex+2]) {
                        case 'r':
                            returnValue = MAR;
                            break;
                        case 'y':
                            returnValue = MAY;
                            break;
                    }
                    break;
            }
            break;
        case 'N':
            returnValue = NOV;
            break;
        case 'O':
            returnValue = OCT;
            break;
        case 'S':
            returnValue = SEP;
            break;
    }
    if (returnValue >= 0) {
        *index += 3;
    }
    return returnValue;
}


/* 
    Parse a year value (either 2 or 4 digits)
 */
static int parseYear(char_t *buf, int *index) 
{
    int tmpIndex, returnValue;

    tmpIndex = *index;
    returnValue = parseNDIGIT(buf, 4, &tmpIndex);

    if (returnValue >= 0) {
        *index = tmpIndex;
    } else {
        returnValue = parseNDIGIT(buf, 2, &tmpIndex);
        if (returnValue >= 0) {
            /*
                Assume that any year earlier than the start of the epoch for time_t (1970) specifies 20xx
             */
            if (returnValue < 70) {
                returnValue += 2000;
            } else {
                returnValue += 1900;
            }
            *index = tmpIndex;
        }
    }
    return returnValue;
}


/* 
    The formulas used to build these functions are from "Calendrical Calculations", by Nachum Dershowitz, Edward M.
    Reingold, Cambridge University Press, 1997.  
 */

//  MOB - move to header
#include <math.h>

//  MOB - static
const int GregorianEpoch = 1;


/*
    Determine if year is a leap year
 */
int GregorianLeapYearP(long year) 
{
    long    tmp;
    
    tmp = year % 400;
    return (year % 4 == 0) && (tmp != 100) && (tmp != 200) && (tmp != 300);
}


/*
    Return the fixed date from the gregorian date
 */
long FixedFromGregorian(long month, long day, long year) 
{
    long fixedDate;

    fixedDate = (long)(GregorianEpoch - 1 + 365 * (year - 1) + 
        floor((year - 1) / 4.0) -
        floor((double)(year - 1) / 100.0) + 
        floor((double)(year - 1) / 400.0) + 
        floor((367.0 * ((double)month) - 362.0) / 12.0));

    if (month <= 2) {
        fixedDate += 0;
    } else if (GregorianLeapYearP(year)) {
        fixedDate += -1;
    } else {
        fixedDate += -2;
    }
    fixedDate += day;
    return fixedDate;
}


/*
    Return the gregorian year from a fixed date
 */
long GregorianYearFromFixed(long fixedDate) 
{
    long result, d0, n400, d1, n100, d2, n4, d3, n1, year;

    d0 =    fixedDate - GregorianEpoch;
    n400 =  (long)(floor((double)d0 / (double)146097));
    d1 =    d0 % 146097;
    n100 =  (long)(floor((double)d1 / (double)36524));
    d2 =    d1 % 36524;
    n4 =    (long)(floor((double)d2 / (double)1461));
    d3 =    d2 % 1461;
    n1 =    (long)(floor((double)d3 / (double)365));
    year =  400 * n400 + 100 * n100 + 4 * n4 + n1;

    if ((n100 == 4) || (n1 == 4)) {
        result = year;
    } else {
        result = year + 1;
    }
    return result;
}


/* 
    Returns the Gregorian date from a fixed date (not needed for this use, but included for completeness)
 */
#if UNUSED && KEEP
void GregorianFromFixed(long fixedDate, long *month, long *day, long *year) 
{
    long priorDays, correction;

    *year =         GregorianYearFromFixed(fixedDate);
    priorDays =     fixedDate - FixedFromGregorian(1, 1, *year);

    if (fixedDate < FixedFromGregorian(3,1,*year)) {
        correction = 0;
    } else if (true == GregorianLeapYearP(*year)) {
        correction = 1;
    } else {
        correction = 2;
    }
    *month = (long)(floor((12.0 * (double)(priorDays + correction) + 373.0) / 367.0));
    *day = fixedDate - FixedFromGregorian(*month, 1, *year);
}
#endif


/* 
    Returns the difference between two Gregorian dates
 */
long GregorianDateDifferenc(long month1, long day1, long year1, long month2, long day2, long year2) 
{
    return FixedFromGregorian(month2, day2, year2) - FixedFromGregorian(month1, day1, year1);
}


/*
    Return the number of seconds into the current day
 */
#define SECONDS_PER_DAY 24*60*60

static int parseTime(char_t *buf, int *index) 
{
    /*  
        Format of buf is - 2DIGIT ":" 2DIGIT ":" 2DIGIT
     */
    int returnValue, tmpIndex, hourValue, minuteValue, secondValue;

    hourValue = minuteValue = secondValue = -1;
    returnValue = -1;
    tmpIndex = *index;

    hourValue = parseNDIGIT(buf, 2, &tmpIndex);

    if (hourValue >= 0) {
        tmpIndex++;
        minuteValue = parseNDIGIT(buf, 2, &tmpIndex);
        if (minuteValue >= 0) {
            tmpIndex++;
            secondValue = parseNDIGIT(buf, 2, &tmpIndex);
        }
    }
    if ((hourValue >= 0) && (minuteValue >= 0) && (secondValue >= 0)) {
        returnValue = (((hourValue * 60) + minuteValue) * 60) + secondValue;
        *index = tmpIndex;
    }
    return returnValue;
}


/*
    Return the equivalent of time() given a gregorian date
 */
static time_t dateToTimet(int year, int month, int day) 
{
    long dayDifference;

    dayDifference = FixedFromGregorian(month + 1, day, year) - FixedFromGregorian(1, 1, 1970);
    return dayDifference * SECONDS_PER_DAY;
}


/*
    Return the number of seconds between Jan 1, 1970 and the parsed date (corresponds to documentation for time() function)
 */
static time_t parseDate1or2(char_t *buf, int *index) 
{
    /*  
        Format of buf is either
        2DIGIT SP month SP 4DIGIT
        or
        2DIGIT "-" month "-" 2DIGIT
     */
    int     dayValue, monthValue, yearValue, tmpIndex;
    time_t  returnValue;

    returnValue = (time_t) -1;
    tmpIndex = *index;

    dayValue = monthValue = yearValue = -1;

    if (buf[tmpIndex] == T(',')) {
        /* 
            Skip over the ", " 
         */
        tmpIndex += 2; 

        dayValue = parseNDIGIT(buf, 2, &tmpIndex);
        if (dayValue >= 0) {
            /*
                Skip over the space or hyphen
             */
            tmpIndex++; 
            monthValue = parseMonth(buf, &tmpIndex);
            if (monthValue >= 0) {
                /*
                    Skip over the space or hyphen
                 */
                tmpIndex++; 
                yearValue = parseYear(buf, &tmpIndex);
            }
        }

        if ((dayValue >= 0) &&
            (monthValue >= 0) &&
            (yearValue >= 0)) {
            if (yearValue < 1970) {
                /*              
                    Allow for Microsoft IE's year 1601 dates 
                 */
                returnValue = 0; 
            } else {
                returnValue = dateToTimet(yearValue, monthValue, dayValue);
            }
            *index = tmpIndex;
        }
    }
    
    return returnValue;
}


/*
    Return the number of seconds between Jan 1, 1970 and the parsed date
 */
static time_t parseDate3Time(char_t *buf, int *index) 
{
    /*
        Format of buf is month SP ( 2DIGIT | ( SP 1DIGIT ))
     */
    int     dayValue, monthValue, yearValue, timeValue, tmpIndex;
    time_t  returnValue;

    returnValue = (time_t) -1;
    tmpIndex = *index;

    dayValue = monthValue = yearValue = timeValue = -1;

    monthValue = parseMonth(buf, &tmpIndex);
    if (monthValue >= 0) {
        /*      
            Skip over the space 
         */
        tmpIndex++; 
        if (buf[tmpIndex] == T(' ')) {
            /*
                Skip over this space too 
             */
            tmpIndex++; 
            dayValue = parseNDIGIT(buf, 1, &tmpIndex);
        } else {
            dayValue = parseNDIGIT(buf, 2, &tmpIndex);
        }
        /*      
            Now get the time and time SP 4DIGIT
         */
        timeValue = parseTime(buf, &tmpIndex);
        if (timeValue >= 0) {
            /*          
                Now grab the 4DIGIT year value
             */
            yearValue = parseYear(buf, &tmpIndex);
        }
    }

    if ((dayValue >= 0) && (monthValue >= 0) && (yearValue >= 0)) {
        returnValue = dateToTimet(yearValue, monthValue, dayValue);
        returnValue += timeValue;
        *index = tmpIndex;
    }
    return returnValue;
}


//  MOB - macro and rename
static int bufferIndexIncrementGivenNTest(char_t *buf, int testIndex, char_t testChar, int foundIncrement, int notfoundIncrement) 
{
    if (buf[testIndex] == testChar) {
        return foundIncrement;
    }
    return notfoundIncrement;
}


/*
    Return an index into a logical weekday array
 */
static int parseWeekday(char_t *buf, int *index) 
{
    /*  
        Format of buf is either
            "Mon" | "Tue" | "Wed" | "Thu" | "Fri" | "Sat" | "Sun"
        or
            "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday"
     */
    int tmpIndex, returnValue;

    returnValue = -1;
    tmpIndex = *index;

    switch (buf[tmpIndex]) {
        case 'F':
            returnValue = FRI;
            *index += bufferIndexIncrementGivenNTest(buf, tmpIndex+3, 'd', sizeof("Friday"), 3);
            break;
        case 'M':
            returnValue = MON;
            *index += bufferIndexIncrementGivenNTest(buf, tmpIndex+3, 'd', sizeof("Monday"), 3);
            break;
        case 'S':
            switch (buf[tmpIndex+1]) {
                case 'a':
                    returnValue = SAT;
                    *index += bufferIndexIncrementGivenNTest(buf, tmpIndex+3, 'u', sizeof("Saturday"), 3);
                    break;
                case 'u':
                    returnValue = SUN;
                    *index += bufferIndexIncrementGivenNTest(buf, tmpIndex+3, 'd', sizeof("Sunday"), 3);
                    break;
            }
            break;
        case 'T':
            switch (buf[tmpIndex+1]) {
                case 'h':
                    returnValue = THU;
                    *index += bufferIndexIncrementGivenNTest(buf, tmpIndex+3, 'r', sizeof("Thursday"), 3);
                    break;
                case 'u':
                    returnValue = TUE;
                    *index += bufferIndexIncrementGivenNTest(buf, tmpIndex+3, 's', sizeof("Tuesday"), 3);
                    break;
            }
            break;
        case 'W':
            returnValue = WED;
            *index += bufferIndexIncrementGivenNTest(buf, tmpIndex+3, 'n', sizeof("Wednesday"), 3);
            break;
    }
    return returnValue;
}


/*
        Parse the date and time string.
 */
static time_t dateParse(time_t tip, char_t *cmd)
{
    int index, tmpIndex, weekday, timeValue;
    time_t parsedValue, dateValue;

    parsedValue = (time_t) 0;
    index = timeValue = 0;
    weekday = parseWeekday(cmd, &index);

    if (weekday >= 0) {
        tmpIndex = index;
        dateValue = parseDate1or2(cmd, &tmpIndex);
        if (dateValue >= 0) {
            index = tmpIndex + 1;
            /*
                One of these two forms is being used
                wkday "," SP date1 SP time SP "GMT"
                weekday "," SP date2 SP time SP "GMT"
             */
            timeValue = parseTime(cmd, &index);
            if (timeValue >= 0) {
                /*              
                    Now match up that "GMT" string for completeness
                    Compute the final value if there were no problems in the parse
                 */
                if ((weekday >= 0) &&
                    (dateValue >= 0) &&
                    (timeValue >= 0)) {
                    parsedValue = dateValue + timeValue;
                }
            }
        } else {
            /* 
                Try the other form - wkday SP date3 SP time SP 4DIGIT
             */
            tmpIndex = index;
            parsedValue = parseDate3Time(cmd, &tmpIndex);
        }
    }

    return parsedValue;
}

#endif /* WEBS_IF_MODIFIED_SUPPORT */


/*
    Return the mime type for the given URL given a URL. The caller supplies the buffer to hold the result.
    charCnt is the number of characters the buffer will hold, ascii or UNICODE.
 */
char_t *websUrlType(char_t *url, char_t *buf, int charCnt)
{
    sym_t   *sp;
    char_t  *ext, *parsebuf;

    gassert(url && *url);
    gassert(buf && charCnt > 0);

    if (url == NULL || *url == '\0') {
        gstrcpy(buf, T("text/plain"));
        return buf;
    }
    if (websUrlParse(url, &parsebuf, NULL, NULL, NULL, NULL, NULL, NULL, &ext) < 0) {
        gstrcpy(buf, T("text/plain"));
        return buf;
    }
    gstrlower(ext);

    /*
        Lookup the mime type symbol table to find the relevant content type
     */
    if ((sp = symLookup(websMime, ext)) != NULL) {
        gstrncpy(buf, sp->content.value.string, charCnt);
    } else {
        gstrcpy(buf, T("text/plain"));
    }
    gfree(parsebuf);
    return buf;
}


/*
    Parse the URL. A buffer is allocated to store the parsed URL in *pbuf. This must be freed by the caller. NOTE: tag
    is not yet fully supported.  
 */
int websUrlParse(char_t *url, char_t **pbuf, char_t **phost, char_t **ppath, char_t **pport, char_t **pquery, 
        char_t **pproto, char_t **ptag, char_t **pext)
{
    char_t      *tok, *cp, *host, *path, *port, *proto, *tag, *query, *ext;
    char_t      *hostbuf, *portbuf, *buf;
    ssize       len, ulen;
    int         c;

    gassert(url);
    gassert(pbuf);

    ulen = gstrlen(url);
    /*
        We allocate enough to store separate hostname and port number fields.  As there are 3 strings in the one buffer,
        we need room for 3 null chars.  We allocate WEBS_MAX_PORT_LEN char_t's for the port number.  
     */
    len = ulen * 2 + WEBS_MAX_PORT_LEN + 3;
    if ((buf = galloc(len * sizeof(char_t))) == NULL) {
        return -1;
    }
    memset(buf, 0, len * sizeof(char_t));
    portbuf = &buf[len - WEBS_MAX_PORT_LEN - 1];
    hostbuf = &buf[ulen+1];
    websDecodeUrl(buf, url, ulen);

    /*
        Convert the current listen port to a string. We use this if the URL has no explicit port setting
     */
    url = buf;
    port = portbuf;
    path = T("/");
    proto = T("http");
    host = T("localhost");
    query = T("");
    ext = htmExt;
    tag = T("");

    if (gstrncmp(url, T("http://"), 7) == 0) {
        tok = &url[7];
        tok[-3] = '\0';
        proto = url;
        host = tok;
        for (cp = tok; *cp; cp++) {
            if (*cp == '/') {
                break;
            }
            if (*cp == ':') {
                *cp++ = '\0';
                port = cp;
                tok = cp;
            }
        }
        if ((cp = gstrchr(tok, '/')) != NULL) {
            /*
                If a full URL is supplied, we need to copy the host and port portions into static buffers.
             */
            c = *cp;
            *cp = '\0';
            gstrncpy(hostbuf, host, ulen);
            gstrncpy(portbuf, port, WEBS_MAX_PORT_LEN);
            *cp = c;
            host = hostbuf;
            port = portbuf;
            path = cp;
            tok = cp;
        }
    } else {
        path = url;
        tok = url;
    }
    /*
        Parse the query string
     */
    if ((cp = gstrchr(tok, '?')) != NULL) {
        *cp++ = '\0';
        query = cp;
        path = tok;
        tok = query;
    } 

    /*
        Parse the fragment identifier
     */
    if ((cp = gstrchr(tok, '#')) != NULL) {
        *cp++ = '\0';
        if (*query == 0) {
            path = tok;
        }
    }
    if (pext) {
        if ((cp = gstrrchr(path, '.')) != NULL) {
            //  MOB - review. See httpCreateUri
            const char_t* garbage = T("/\\");
            ssize length = gstrcspn(cp, garbage);
            ssize glen = gstrspn(cp + length, garbage);
            ssize ok = (cp[length + glen] == '\0');
            if (ok) {
                cp[length] = '\0';
#if BIT_WIN_LIKE
                gstrlower(cp);            
                //  MOB - don't map extension case. Those who test should use caseless test
#endif
                ext = cp;
            }
        }
    }
    /*
        Pass back the fields requested (if not NULL)
     */
    if (phost)
        *phost = host;
    if (ppath)
        *ppath = path;
    if (pport)
        *pport = port;
    if (pproto)
        *pproto = proto;
    if (pquery)
        *pquery = query;
    if (ptag)
        *ptag = tag;
    if (pext)
        *pext = ext;
    *pbuf = buf;
    return 0;
}


/*
    Normalize a URI path to remove redundant "./" and cleanup "../" and make separator uniform. Does not make an abs path.
    It does not map separators nor change case. 
 */
char_t *websNormalizeUriPath(char_t *pathArg)
{
    char    *dupPath, *path, *sp, *dp, *mark, **segments;
    int     firstc, j, i, nseg, len;

    if (pathArg == 0 || *pathArg == '\0') {
        return "";
    }
    len = (int) glen(pathArg);
    if ((dupPath = galloc(len + 2)) == 0) {
        return NULL;
    }
    strcpy(dupPath, pathArg);

    if ((segments = galloc(sizeof(char*) * (len + 1))) == 0) {
        return NULL;
    }
    nseg = len = 0;
    firstc = *dupPath;
    for (mark = sp = dupPath; *sp; sp++) {
        if (*sp == '/') {
            *sp = '\0';
            while (sp[1] == '/') {
                sp++;
            }
            segments[nseg++] = mark;
            len += (int) (sp - mark);
            mark = sp + 1;
        }
    }
    segments[nseg++] = mark;
    len += (int) (sp - mark);
    for (j = i = 0; i < nseg; i++, j++) {
        sp = segments[i];
        if (sp[0] == '.') {
            if (sp[1] == '\0')  {
                if ((i+1) == nseg) {
                    segments[j] = "";
                } else {
                    j--;
                }
            } else if (sp[1] == '.' && sp[2] == '\0')  {
                if (i == 1 && *segments[0] == '\0') {
                    j = 0;
                } else if ((i+1) == nseg) {
                    if (--j >= 0) {
                        segments[j] = "";
                    }
                } else {
                    j = max(j - 2, -1);
                }
            }
        } else {
            segments[j] = segments[i];
        }
    }
    nseg = j;
    gassert(nseg >= 0);
    if ((path = galloc(len + nseg + 1)) != 0) {
        for (i = 0, dp = path; i < nseg; ) {
            strcpy(dp, segments[i]);
            len = (int) glen(segments[i]);
            dp += len;
            if (++i < nseg || (nseg == 1 && *segments[0] == '\0' && firstc == '/')) {
                *dp++ = '/';
            }
        }
        *dp = '\0';
    }
    return path;
}


/*
    Open a web page. lpath is the local filename. path is the URL path name.
 */
int websPageOpen(Webs *wp, char_t *lpath, char_t *path, int mode, int perm)
{
    gassert(websValid(wp));
#if BIT_ROM
    return websRomPageOpen(wp, path, mode, perm);
#else
    return (wp->docfd = gopen(lpath, mode, perm));
#endif
}


void websPageClose(Webs *wp)
{
    gassert(websValid(wp));

#if BIT_ROM
    websRomPageClose(wp->docfd);
#else
    if (wp->docfd >= 0) {
        close(wp->docfd);
        wp->docfd = -1;
    }
#endif
}


/*
    Stat a web page lpath is the local filename. path is the URL path name.
 */
int websPageStat(Webs *wp, char_t *lpath, char_t *path, WebsFileInfo *sbuf)
{
#if BIT_ROM
    return websRomPageStat(path, sbuf);
#else
    WebsStat    s;

    if (gstat(lpath, &s) < 0) {
        return -1;
    }
    sbuf->size = (ssize) s.st_size;
    sbuf->mtime = s.st_mtime;
    sbuf->isDir = s.st_mode & S_IFDIR;
    return 0;
#endif
}


int websPageIsDirectory(char_t *lpath)
{
#if BIT_ROM
    WebsFileInfo    sbuf;

    if (websRomPageStat(lpath, &sbuf) >= 0) {
        return(sbuf.isDir);
    } else {
        return 0;
    }
#else
    WebsStat    sbuf;

    if (gstat(lpath, &sbuf) >= 0) {
        return(sbuf.st_mode & S_IFDIR);
    } else {
        return 0;
    }
#endif
}


/*
    Read a web page. Returns the number of _bytes_ read. len is the size of buf, in bytes.
 */
ssize websPageReadData(Webs *wp, char *buf, ssize nBytes)
{

#if BIT_ROM
    gassert(websValid(wp));
    return websRomPageReadData(wp, buf, nBytes);
#else
    gassert(websValid(wp));
    return read(wp->docfd, buf, nBytes);
#endif
}


/*
    Move file pointer offset bytes.
 */
void websPageSeek(Webs *wp, EgFilePos offset)
{
    gassert(websValid(wp));

#if BIT_ROM
    websRomPageSeek(wp, offset, SEEK_CUR);
#else
    lseek(wp->docfd, (long) offset, SEEK_CUR);
#endif
}


void websSetCookie(Webs *wp, char_t *name, char_t *value, char_t *path, char_t *cookieDomain, time_t lifespan, int flags)
{
    time_t  when;
    char    *cp, *expiresAtt, *expires, *domainAtt, *domain, *secure, *httponly, *cookie, *old;

    if (path == 0) {
        path = "/";
    }
    if (!cookieDomain) {
        domain = gstrdup(websGetVar(wp, T("HTTP_HOST"), ""));
        if ((cp = strchr(domain, ':')) != 0) {
            /* Strip port */
            *cp = '\0';
        }
        if (*domain && domain[strlen(domain) - 1] == '.') {
            /* Cleanup bonjour addresses with trailing dot */
            domain[strlen(domain) - 1] = '\0';
        }
    } else {
        domain = gstrdup(cookieDomain);
    }
    domainAtt = domain ? "; domain=" : "";
    if (domain && !strchr(domain, '.')) {
        old = domain;
        gfmtAlloc(&domain, -1, ".%s", domain);
        gfree(old);
    }
    if (lifespan > 0) {
        expiresAtt = "; expires=";
        when = time(0) + lifespan;
        if ((expires = gctime(&when)) != NULL) {
            expires[gstrlen(expires) - 1] = '\0';
        }

    } else {
        expiresAtt = "";
        expires = "";
    }
    /* 
       Allow multiple cookie headers. Even if the same name. Later definitions take precedence
     */
    secure = (flags & WEBS_COOKIE_SECURE) ? "; secure" : "";
    httponly = (flags & WEBS_COOKIE_HTTP) ?  "; httponly" : "";
    gfmtAlloc(&cookie, -1, "%s=%s; path=%s%s%s%s%s%s%s", name, value, path, domainAtt, domain, expiresAtt, expires, secure, 
        httponly);
    if (wp->responseCookie) {
        old = wp->responseCookie;
        gfmtAlloc(&wp->responseCookie, -1, "%s %s", wp->responseCookie, cookie);
        gfree(old);
        gfree(cookie);
    } else {
        wp->responseCookie = cookie;
    }
    gfree(domain);
}


#if BIT_SESSIONS
static char *makeSessionID(Webs *wp)
{
    char        idBuf[64];
    static int  nextSession = 0;

    gfmtStatic(idBuf, sizeof(idBuf), "%08x%08x%d", PTOI(wp) + PTOI(wp->url), (int) time(0), nextSession++);
    return websMD5binary(idBuf, sizeof(idBuf), "::webs.session::");
}


WebsSession *websAllocSession(Webs *wp, char_t *id, time_t lifespan)
{
    WebsSession     *sp;

    if ((sp = galloc(sizeof(WebsSession))) == 0) {
        return 0;
    }
    sp->lifespan = lifespan;
    sp->expires = time(0) + lifespan;
    if (id == 0) {
        id = makeSessionID(wp);
    }
    sp->id = gstrdup(id);
    sp->user = 0;
    if ((sp->cache = symOpen(WEBS_SESSION_HASH)) == 0) {
        return 0;
    }
    return sp;
}


static void freeSession(WebsSession *sp)
{
    gfree(sp->id);
    gfree(sp);
}


WebsSession *websGetSession(Webs *wp, int create)
{
    socket_t    *sp;
    sym_t       *sym;
    char_t      *id;
    
    if (!wp->session) {
        id = websGetSessionID(wp);
        if ((sym = symLookup(sessions, id)) == 0) {
            if (!create) {
                return 0;
            }
            if (sessionCount > BIT_LIMIT_SESSION_COUNT) {
                error(T("Too many sessions %d/%d"), sessionCount, BIT_LIMIT_SESSION_COUNT);
                return 0;
            }
            sessionCount++;
            if ((wp->session = websAllocSession(wp, id, BIT_LIMIT_SESSION_LIFE)) == 0) {
                return 0;
            }
            if ((sym = symEnter(sessions, wp->session->id, valueSymbol(wp->session), 0)) == 0) {
                return 0;
            }
            wp->session = (WebsSession*) sym->content.value.symbol;
            sp = socketPtr(wp->sid);
            websSetCookie(wp, WEBS_SESSION, wp->session->id, "/", NULL, 0, sp->secure ? 1 : 0);
        } else {
            wp->session = (WebsSession*) sym->content.value.symbol;
        }
    }
    if (wp->session) {
        wp->session->expires = time(0) + wp->session->lifespan;
    }
    return wp->session;
}


char *websGetSessionID(Webs *wp)
{
    char_t  *cookies, *cookie;
    char_t  *cp, *value;
    ssize   len;
    int     quoted;

    if (wp->session) {
        return wp->session->id;
    }
    cookies = wp->cookie;
    for (cookie = cookies; cookie && (value = gstrstr(cookie, WEBS_SESSION)) != 0; cookie = value) {
        value += strlen(WEBS_SESSION);
        while (isspace((uchar) *value) || *value == '=') {
            value++;
        }
        quoted = 0;
        if (*value == '"') {
            value++;
            quoted++;
        }
        for (cp = value; *cp; cp++) {
            if (quoted) {
                if (*cp == '"' && cp[-1] != '\\') {
                    break;
                }
            } else {
                if ((*cp == ',' || *cp == ';') && cp[-1] != '\\') {
                    break;
                }
            }
        }
        len = cp - value;
        if ((cp = galloc(len + 1)) == 0) {
            return 0;
        }
        strncpy(cp, value, len);
        cp[len] = '\0';
        return cp;
    }
    return 0;
}


char_t *websGetSessionVar(Webs *wp, char_t *key, char_t *defaultValue)
{
    WebsSession     *sp;
    sym_t           *sym;

    if ((sp = websGetSession(wp, 1)) != 0) {
        if ((sym = symLookup(sp->cache, key)) == 0) {
            return defaultValue;
        }
        return (char_t*) sym->content.value.symbol;
    }
    return 0;
}


int websSetSessionVar(Webs *wp, char_t *key, char_t *value)
{
    WebsSession  *sp;

    gassert(key && *key);

    if ((sp = websGetSession(wp, 1)) == 0) {
        return 0;
    }
    if (symEnter(sp->cache, key, valueSymbol(value), 0) == 0) {
        return -1;
    }
    return 0;
}


/*
    Get the next token from the input ringq. This eats leading spaces and tabs.
 */
static char *getToken(Webs *wp, char *delim)
{
    ringq_t     *buf;
    char        *token, *nextToken, *endToken;

    gassert(wp);
    buf = &wp->input;
    nextToken = (char*) buf->endp;

    for (token = (char*) buf->servp; (*token == ' ' || *token == '\t') && token < (char*) buf->endp; token++) {}

    if (delim == 0) {
        delim = " \t";
        if ((endToken = strpbrk(token, delim)) != 0) {
            nextToken = endToken + strspn(endToken, delim);
            *endToken = '\0';
        }
    } else {
        if ((endToken = strstr(token, delim)) != 0) {
            *endToken = '\0';
            /* Only eat one occurence of the delimiter */
            nextToken = endToken + strlen(delim);
        } else {
            nextToken = buf->endp;
        }
    }
    buf->servp = nextToken;
    return token;
}


static void pruneCache()
{
    WebsSession     *sp;
    time_t          when;
    sym_t           *sym, *next;

    //  MOB - should limit size of session cache
    when = time(0);
    for (sym = symFirst(sessions); sym; sym = next) {
        next = symNext(sessions, sym);
        sp = (WebsSession*) sym->content.value.symbol;
        if (sp->expires <= when) {
            symDelete(sessions, sp->id);
            //  MOB - must make sure that no request is active using sp!!!
            //  Do we need acquire / release
            sessionCount--;
            freeSession(sp);
        }
    }
    greschedCallback(pruneId, WEBS_SESSION_PRUNE);
}
#endif /* BIT_SESSIONS */

/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2012. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis GoAhead open source license or you may acquire 
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
