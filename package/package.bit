/*
    package.bit -- Package targets for GoAhead
 */

Bit.load({
    targets: {
        removeFiles: {
            enable: "bit.platform.like == 'windows'",
            type: 'exe',
            rule: 'gui'
            sources: [ 'windows/removeFiles.c' ],
            platforms: [ 'local' ],
        },

        deploy: {
            home: '${TOP}',
            action: 'packageDeploy()',
            depends: ['compile'],
            'generate-make': "
                rm -f $(BIT_UBIN_PREFIX)/bit
                mkdir -p '$(BIT_CFG_PREFIX)' '$(BIT_BIN_PREFIX)' '$(BIT_WEB_PREFIX)' '$(BIT_VER_PREFIX)/man/man1'
                cp src/auth.txt src/route.txt $(BIT_CFG_PREFIX)
                cp -R -P ${BIN}/goahead ${BIN}/ca.crt ${BIN}/lib* $(BIT_BIN_PREFIX)
                cp -R -P src/web/index.html $(BIT_WEB_PREFIX)
                rm -f $(BIT_PRD_PREFIX)/latest
                ln -s $(VERSION) $(BIT_PRD_PREFIX)/latest
                for n in goahead gopass webcomp ; do \\
                    rm -f $(BIT_UBIN_PREFIX)/$$n ; \\
                    ln -s $(BIT_BIN_PREFIX)/$$n $(BIT_UBIN_PREFIX)/$$n ; \\
                done
                for n in goahead.1 gopass.1 webcomp.1; do \\
                    rm -f $(BIT_VER_PREFIX)/man/man1/$$n $(BIT_MAN_PREFIX)/$$n ; \\
                    cp doc/man/$$n $(BIT_VER_PREFIX)/man/man1 ; \\
                    ln -s $(BIT_VER_PREFIX)/man/man1/$$n $(BIT_MAN_PREFIX)/$$n ; \\
                done
            ",
            'generate-nmake': "
                xcopy /I /S /Y /Q $(CONFIG)\\bin \"$(BIT_BIN_PREFIX)\"
                del /Q \"$(BIT_BIN_PREFIX)\\*.pdb\"
                del /Q \"$(BIT_BIN_PREFIX)\\*.exp\"
                del /Q \"$(BIT_BIN_PREFIX)\\*.lib\"
                copy src/auth.txt src/route.txt \"$(BIT_PRD_PREFIX)\"
            ",
        },

        install: {
            enable: "bit.platform.like == 'posix' || bit.platform.like == 'windows'",                      
            home: '${TOP}',
            action: "installBinary()",
            depends: ['compile', 'deploy'],
            'generate': ' ',
        },

        uninstall: {
            enable: "bit.platform.like == 'posix' || bit.platform.like == 'windows'",                      
            home: '${TOP}',
            action: 'uninstallBinary()',
            'generate-make': "
                rm -fr $(BIT_CFG_PREFIX) $(BIT_PRD_PREFIX)
                for n in goahead gopass webcmop; do rm -f $(BIT_UBIN_PREFIX)/$$n ; done
                for n in $(BIT_VER_PREFIX)/man/man1/*.1; do \\
                    base=`basename $$n` ; \\
                    rm -f $(BIT_MAN_PREFIX)/$$base ; \\
                done
                rm -fr '$(BIT_CFG_PREFIX)' '$(BIT_PRD_PREFIX)' '$(BIT_WEB_PREFIX)'
            ",
            'generate-nmake': "if exist \"$(BIT_PRD_PREFIX)\" rd /Q /S \"$(BIT_PRD_PREFIX)\"",
        },

        package: {
            home: '${TOP}',
            enable: "'${OS}' == 'linux' || '${OS}' == 'macosx' || '${OS}' == 'windows'",
            depends: ['packageBinary', 'packageSource', 'packageCombo'],
        },

        packageBinary: {
            home: '${TOP}',
            depends: ['build'],
            action: "packageBinaryFiles()",
        },

        packageSource: {
            home: '${TOP}',
            depends: ['build'],
            action: "packageSourceFiles()",
        },

        packageCombo: {
            home: '${TOP}',
            depends: ['build'],
            action: "packageComboFiles()",
        },

        testPackage: {
            type: 'test',
            action: "
                let package = packageName()
                if (!package || !package.exists || bit.settings.depth < 2) {
                    trace('Test', 'testPackage -- SKIPPED (Runs at depth 2 on windows or macosx)')
                } else {
                    if (Config.OS == 'macosx' && App.uid != 0) {
                        trace('Test', 'testPackage -- SKIPPED (Must run as root)')
                    } else {
                        trace('Test', 'testPackage')
                        if (bit.prefixes.bin.join('uninstall').exists) {
                            trace('Test', 'Cleanup prior to installation')
                            uninstallPackage()
                            checkUninstalled()
                        }
                        installPackage()
                        if (missing = checkInstalled()) {
                            trace('Test', 'Install is missing files: ' + missing)
                        }
                        let s = bit.settings
                        uninstallPackage()
                        if (Config.OS == 'windows') App.sleep(1000)
                        if (existing = checkUninstalled()) {
                            trace('Warning', 'The uninstall for testPackage was not clean: ' + existing)
                        } else {
                            trace('Test', 'Uninstall is clean')
                        }
                    }
                }
            ",
        },
    },
})
