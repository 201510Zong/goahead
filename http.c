/*
    http.c -- GoAhead HTTP engine

    This module implements an embedded HTTP/1.1 web server. It supports
    loadable URL handlers that define the nature of URL processing performed.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/********************************* Includes ***********************************/

#include    "goahead.h"

/*********************************** Globals **********************************/

static int  websBackground;             /* Run as a daemon */
static int  websDebug;                  /* Run in debug mode and defeat timeouts */

/************************************ Locals **********************************/

static int          listens[WEBS_MAX_LISTEN];   /* Listen endpoints */;
static int          listenMax;

//  MOB - remove webs prefix
static Webs         **webs;                     /* Open connection list head */
static WebsHash     websMime;                   /* Set of mime types */
static int          websMax;                    /* List size */

static char       websHost[64];               /* Host name for the server */
static char       websIpAddr[64];             /* IP address for the server */
static char       *websHostUrl = NULL;        /* URL to access server */
static char       *websIpAddrUrl = NULL;      /* URL to access server */

#define WEBS_ENCODE_HTML    0x1         /* Bit setting in charMatch[] */

/*
    Character escape/descape matching codes. Generated by charGen.
 */
static uchar charMatch[256] = {
    0x00,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3e,0x3c,0x3c,0x3c,0x3c,0x3c,
    0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,
    0x3c,0x0c,0x3f,0x28,0x2a,0x3c,0x2b,0x0f,0x0e,0x0e,0x0e,0x28,0x28,0x00,0x00,0x28,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x28,0x2a,0x3f,0x28,0x3f,0x2a,
    0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3a,0x3e,0x3a,0x3e,0x00,
    0x3e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3e,0x3e,0x3e,0x02,0x3c,
    0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,
    0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,
    0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,
    0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,
    0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,
    0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,
    0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,
    0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c 
};

/*
    Addd entries to the MimeList as required for your content
    MOB - compare with appweb
    MOB - should remove "." from list
 */
static WebsMime websMimeList[] = {
    { "application/java", ".class" },
    { "application/java", ".jar" },
    { "text/html", ".asp" },
    { "text/html", ".htm" },
    { "text/html", ".html" },
    { "text/xml", ".xml" },
    { "image/gif", ".gif" },
    { "image/jpeg", ".jpg" },
    { "image/png", ".png" },
    { "image/vnd.microsoft.icon", ".ico" },
    { "text/css", ".css" },
    { "text/plain", ".txt" },
    { "application/x-javascript", ".js" },
    { "application/x-shockwave-flash", ".swf" },

    { "application/binary", ".exe" },
    { "application/compress", ".z" },
    { "application/gzip", ".gz" },
    { "application/octet-stream", ".bin" },
    { "application/oda", ".oda" },
    { "application/pdf", ".pdf" },
    { "application/postscript", ".ai" },
    { "application/postscript", ".eps" },
    { "application/postscript", ".ps" },
    { "application/rtf", ".rtf" },
    { "application/x-bcpio", ".bcpio" },
    { "application/x-cpio", ".cpio" },
    { "application/x-csh", ".csh" },
    { "application/x-dvi", ".dvi" },
    { "application/x-gtar", ".gtar" },
    { "application/x-hdf", ".hdf" },
    { "application/x-latex", ".latex" },
    { "application/x-mif", ".mif" },
    { "application/x-netcdf", ".nc" },
    { "application/x-netcdf", ".cdf" },
    { "application/x-ns-proxy-autoconfig", ".pac" },
    { "application/x-patch", ".patch" },
    { "application/x-sh", ".sh" },
    { "application/x-shar", ".shar" },
    { "application/x-sv4cpio", ".sv4cpio" },
    { "application/x-sv4crc", ".sv4crc" },
    { "application/x-tar", ".tar" },
    { "application/x-tgz", ".tgz" },
    { "application/x-tcl", ".tcl" },
    { "application/x-tex", ".tex" },
    { "application/x-texinfo", ".texinfo" },
    { "application/x-texinfo", ".texi" },
    { "application/x-troff", ".t" },
    { "application/x-troff", ".tr" },
    { "application/x-troff", ".roff" },
    { "application/x-troff-man", ".man" },
    { "application/x-troff-me", ".me" },
    { "application/x-troff-ms", ".ms" },
    { "application/x-ustar", ".ustar" },
    { "application/x-wais-source", ".src" },
    { "application/zip", ".zip" },
    { "audio/basic", ".au snd" },
    { "audio/x-aiff", ".aif" },
    { "audio/x-aiff", ".aiff" },
    { "audio/x-aiff", ".aifc" },
    { "audio/x-wav", ".wav" },
    { "audio/x-wav", ".ram" },
    { "image/ief", ".ief" },
    { "image/jpeg", ".jpeg" },
    { "image/jpeg", ".jpe" },
    { "image/tiff", ".tiff" },
    { "image/tiff", ".tif" },
    { "image/x-cmu-raster", ".ras" },
    { "image/x-portable-anymap", ".pnm" },
    { "image/x-portable-bitmap", ".pbm" },
    { "image/x-portable-graymap", ".pgm" },
    { "image/x-portable-pixmap", ".ppm" },
    { "image/x-rgb", ".rgb" },
    { "image/x-xbitmap", ".xbm" },
    { "image/x-xpixmap", ".xpm" },
    { "image/x-xwindowdump", ".xwd" },
    { "text/html", ".cfm" },
    { "text/html", ".shtm" },
    { "text/html", ".shtml" },
    { "text/richtext", ".rtx" },
    { "text/tab-separated-values", ".tsv" },
    { "text/x-setext", ".etx" },
    { "video/mpeg", ".mpeg" },
    { "video/mpeg", ".mpg" },
    { "video/mpeg", ".mpe" },
    { "video/quicktime", ".qt" },
    { "video/quicktime", ".mov" },
    { "video/x-msvideo", ".avi" },
    { "video/x-sgi-movie", ".movie" },
    { NULL, NULL},
};

/*
    Standard HTTP error codes
 */
static WebsError websErrors[] = {
    { 200, "OK" },
    { 201, "Created" },
    { 204, "No Content" },
    { 205, "Reset Content" },
    { 206, "Partial Content" },
    { 301, "Redirect" },
    { 302, "Redirect" },
    { 304, "Not Modified" },
    { 400, "Bad Request" },
    { 401, "Unauthorized" },
    { 402, "Payment required" },
    { 403, "Forbidden" },
    { 404, "Not Found" },
    { 405, "Access Denied" },
    { 406, "Not Acceptable" },
    { 408, "Request Timeout" },
    { 413, "Request too large" },
    { 500, "Internal Server Error" },
    { 501, "Not Implemented" },
    { 503, "Service Unavailable" },
    { 0, NULL }
};

//  MOB - should be main.bit
#if BIT_ACCESS_LOG
static char   accessLog[64] = "access.log";    /* Log filename */
static int      accessFd;                           /* Log file handle */
#endif

static WebsHash sessions = -1;
static int      sessionCount = 0;
static int      pruneId;                            /* Callback ID */

/**************************** Forward Declarations ****************************/

static time_t   getTimeSinceMark(Webs *wp);
static char     *getToken(Webs *wp, char *delim);
static bool     parseFirstLine(Webs *wp);
static bool     parseHeaders(Webs *wp);
static bool     processContent(Webs *wp);
extern bool     parseIncoming(Webs *wp);
extern bool     processParsed(Webs *wp);
static void     reuseConn(Webs *wp);
static int      setLocalHost();
static void     socketEvent(int sid, int mask, void* data);

static void     websPump(Webs *wp);

static void     pruneCache();
#if BIT_ACCESS_LOG
static void     logRequest(Webs *wp, int code);
#endif
static time_t   dateParse(time_t tip, char *cmd);

/*********************************** Code *************************************/

int websOpen(char *documents, char *authPath)
{
    WebsMime    *mt;

    webs = NULL;
    websMax = 0;

#if SOLARIS
    openlog(BIT_PRODUCT, LOG_LOCAL0);
#elif BIT_UNIX_LIKE
    openlog(BIT_PRODUCT, 0, LOG_LOCAL0);
#endif
#if WINDOWS || VXWORKS
    rand();
#else
    random();
#endif
    traceOpen();
    socketOpen();
    if (setLocalHost() < 0) {
        return -1;
    }
#if BIT_PACK_SSL
    if (sslOpen() < 0) {
        return -1;
    }
#endif 
    if ((sessions = symOpen(WEBS_SMALL_HASH)) < 0) {
        return -1;
    }
    if (!websDebug) {
        pruneId = gschedCallback(WEBS_SESSION_PRUNE, (WebsCallback*) pruneCache, 0);
    }
    if (documents) {
        websSetDocuments(documents);
    }
    websUploadOpen();
    websProcOpen();
#if BIT_JAVASCRIPT
    websJsOpen();
#endif

    if (websOpenAuth() < 0) {
        return -1;
    }
    if (websOpenRoute(authPath) < 0) {
        return -1;
    }
#if BIT_ROM
    websRomOpen();
#endif
    websFileOpen();

    /*
        Create a mime type lookup table for quickly determining the content type
     */
    websMime = symOpen(WEBS_SYM_INIT * 4);
    gassert(websMime >= 0);
    for (mt = websMimeList; mt->type; mt++) {
        symEnter(websMime, mt->ext, valueString(mt->type, 0), 0);
    }
    if (websUrlHandlerOpen() < 0) {
        return -1;
    }

#if BIT_ACCESS_LOG
    if ((accessFd = open(accessLog, O_CREAT | O_TRUNC | O_APPEND | O_WRONLY, 0666)) < 0) {
        error("Can't open access log %s", accessLog);
        return -1;
    }
    /* Some platforms don't implement O_APPEND (VXWORKS) */
    lseek(accessFd, 0, SEEK_END);
#endif
    return 0;
}


void websClose() 
{
    Webs    *wp;
    int     i;

#if BIT_JAVASCRIPT
    websJsClose();
#endif
    websCloseRoute();
    websCloseAuth();
    if (pruneId >= 0) {
        gunschedCallback(pruneId);
        pruneId = -1;
    }
    if (sessions >= 0) {
        symClose(sessions);
        sessions = -1;
    }
    for (i = 0; i < listenMax; i++) {
        socketCloseConnection(listens[i]);
        listens[i] = -1;
    }
    for (i = listenMax; i >= 0; i--) {
        socketCloseConnection(listens[i]);
    }
    listenMax = 0;
    for (i = websMax; webs && i >= 0; i--) {
        if ((wp = webs[i]) == NULL) {
            continue;
        }
        socketCloseConnection(wp->sid);
        websFree(wp);
    }
    gfree(websHostUrl);
    gfree(websIpAddrUrl);
    websIpAddrUrl = websHostUrl = NULL;

#if BIT_PACK_SSL
    sslClose();
#endif
#if BIT_ACCESS_LOG
    if (accessFd >= 0) {
        close(accessFd);
        accessFd = -1;
    }
#endif
#if BIT_ROM
    websRomClose();
#endif
    websFileClose();
    symClose(websMime);
    websProcClose();
    websUrlHandlerClose();
    socketClose();
    traceClose();
#if BIT_UNIX_LIKE
    closelog();
#endif
}


static void initWebs(Webs *wp, int wid, int sid, int flags, ringq_t *input)
{
    memset(wp, 0, sizeof(Webs));
    wp->flags = flags;
    wp->state = WEBS_BEGIN;
    wp->wid = wid;
    wp->sid = sid;
    wp->docfd = -1;
    wp->putfd = -1;
    wp->timeout = -1;
    wp->txLen = -1;
    wp->rxLen = -1;
#if BIT_CGI
    wp->cgifd = -1;
#endif
#if BIT_UPLOAD
    wp->upfd = -1;
#endif
    wp->vars = symOpen(WEBS_SYM_INIT);
    ringqOpen(&wp->output, BIT_LIMIT_RESPONSE_BUFFER, BIT_LIMIT_RESPONSE_BUFFER);
    if (input) {
        wp->input = *input;
    } else {
        ringqOpen(&wp->input, BIT_LIMIT_HEADERS, BIT_LIMIT_HEADERS + BIT_LIMIT_BODY);
    }
}


static void termWebs(Webs *wp, int keepAlive)
{
    //  MOB - OPT reduce allocations
    gfree(wp->authDetails);
    gfree(wp->authResponse);
    gfree(wp->authType);
    gfree(wp->contentType);
    gfree(wp->cookie);
    gfree(wp->decodedQuery);
    gfree(wp->digest);
    gfree(wp->dir);
    gfree(wp->ext);
    gfree(wp->filename);
    gfree(wp->host);
    gfree(wp->inputFile);
    gfree(wp->method);
    gfree(wp->password);
    gfree(wp->path);
    gfree(wp->protoVersion);
    gfree(wp->protocol);
    gfree(wp->query);
    gfree(wp->realm);
    gfree(wp->responseCookie);
    gfree(wp->url);
    gfree(wp->userAgent);
    gfree(wp->username);
#if BIT_CGI
    gfree(wp->cgiStdin);
#endif
#if BIT_DIGEST
    gfree(wp->cnonce);
    gfree(wp->digestUri);
    gfree(wp->opaque);
    gfree(wp->nc);
    gfree(wp->nonce);
    gfree(wp->qop);
#endif
    symClose(wp->vars);
#if BIT_PACK_SSL
    sslFree(wp);
#endif
#if BIT_UPLOAD
    if (wp->files) {
        websFreeUpload(wp);
    }
#endif
    ringqClose(&wp->output);
    if (!keepAlive) {
        ringqClose(&wp->input);
    }
}


int websAlloc(int sid)
{
    Webs    *wp;
    int     wid;

    if ((wid = gallocEntry((void***) &webs, &websMax, sizeof(Webs))) < 0) {
        return -1;
    }
    wp = webs[wid];
    initWebs(wp, wid, sid, 0, 0);
    wp->sid = sid;
    return wid;
}


static void reuseConn(Webs *wp)
{
    ringq_t     input;
    int         flags, sid, wid;

    gassert(websValid(wp));

    flags = wp->flags & (WEBS_KEEP_ALIVE | WEBS_SECURE | WEBS_HTTP11);
    sid = wp->sid;
    wid = wp->wid;
    ringqCompact(&wp->input);
    if (ringqLen(&wp->input)) {
        socketReservice(wp->sid);
    }
    input = wp->input;
    termWebs(wp, 1);
    initWebs(wp, wid, sid, flags, &input);
}


void websFree(Webs *wp)
{
    gassert(websValid(wp));

    termWebs(wp, 0);
    websMax = gfreeHandle((void***) &webs, wp->wid);
    gfree(wp);
    gassert(websMax >= 0);
}


/*
    Called when the request is complete.
 */
void websDone(Webs *wp, int code)
{
    gassert(websValid(wp));

    websFlush(wp, 1);
    if (wp->code == 0) {
        wp->code = code & ~WEBS_CLOSE;
    }
    if (wp->rxConsumed < wp->rxLen) {
        ringqGetBlkAdj(&wp->input, wp->rxLen - wp->rxConsumed);
    }
    if (!wp->flags & WEBS_RESPONSE_TRACED) {
        trace(3 | WEBS_LOG_RAW, "Request complete: code %d", code);
    }
    socketDeleteHandler(wp->sid);
#if BIT_ACCESS_LOG
    logRequest(wp, wp->code);
#endif
    websPageClose(wp);
#if BIT_CGI
    if (wp->cgifd >= 0) {
        close(wp->cgifd);
        wp->cgifd = -1;
    }
#endif
    if (wp->putfd >= 0) {
        close(wp->putfd);
        wp->putfd = -1;
    }
#if BIT_PACK_SSL
    if (wp->flags & WEBS_SECURE) {
        websTimeoutCancel(wp);
        //  MOB - why close connection. Why not keep-alive?
        socketCloseConnection(wp->sid);
        websFree(wp);
        return;
    }
#endif
    if (wp->flags & WEBS_KEEP_ALIVE && wp->rxRemaining == 0) {
        websTimeoutCancel(wp);
        reuseConn(wp);
        socketCreateHandler(wp->sid, SOCKET_READABLE, socketEvent, wp);
        wp->timeout = gschedCallback(WEBS_TIMEOUT, websTimeout, (void *) wp);
        trace(5, "Keep connection alive\n");
        return;
    }
    websTimeoutCancel(wp);
    socketCloseConnection(wp->sid);
    websFree(wp);
    trace(5, "Close connection\n");
}


int websListen(char *endpoint)
{
    socket_t    *sp;
    char        *ip, *ipaddr;
    int         port, secure, sid;

    if (listenMax >= WEBS_MAX_LISTEN) {
        error("Too many listen endpoints");
        return -1;
    }
    socketParseAddress(endpoint, &ip, &port, &secure, 80);
    if ((sid = socketListen(ip, port, websAccept, 0)) < 0) {
        error("Unable to open socket on port %d.", port);
        return -1;
    }
    sp = socketPtr(sid);
    sp->secure = secure;
    listens[listenMax++] = sid;
    if (ip) {
        ipaddr = smatch(ip, "::") ? "[::]" : ip;
    } else {
        ipaddr = "*";
    }
    trace(0, "Started %s://%s:%d\n", secure ? "https" : "http", ipaddr, port);
    gfree(ip);

    if (!websHostUrl) {
        if (port == 80) {
            websHostUrl = strdup(ip ? ip : websIpAddr);
        } else {
            websHostUrl = sfmt("%s:%d", ip ? ip : websIpAddr, port);
        }
    }
    if (!websIpAddrUrl) {
        if (port == 80) {
            websIpAddrUrl = strdup(websIpAddr);
        } else {
            websIpAddrUrl = sfmt("%s:%d", websIpAddr, port);
        }
    }
    return sid;
}


void websCloseListen(int sid)
{
    int     i;

    if (sid >= 0) {
        socketCloseConnection(sid);
        for (i = 0; i < listenMax; i++) {
            if (listens[i] == sid) {
                for (; i < listenMax; i++) {
                    listens[i] = listens[i+1];
                }
                break;
            }
        }
    }
}


/*
    Accept a new connection from ipaddr:port 
 */
int websAccept(int sid, char *ipaddr, int port, int listenSid)
{
    Webs        *wp;
    struct sockaddr_storage ifAddr;
    int         wid, len;

    gassert(ipaddr && *ipaddr);
    gassert(sid >= 0);
    gassert(port >= 0);

    /*
        Allocate a new handle for this accepted connection. This will allocate a Webs structure in the webs[] list
     */
    if ((wid = websAlloc(sid)) < 0) {
        return -1;
    }
    wp = webs[wid];
    gassert(wp);
    wp->listenSid = listenSid;
    strncpy(wp->ipaddr, ipaddr, min(sizeof(wp->ipaddr) - 1, strlen(ipaddr)));

    /*
        Get the ip address of the interface that accept the connection.
     */
    len = sizeof(ifAddr);
    if (getsockname(socketList[sid]->sock, (struct sockaddr*) &ifAddr, (WebsSockLenArg*) &len) < 0) {
        error("Can't get sockname");
        return -1;
    }
    socketAddress((struct sockaddr*) &ifAddr, (int) len, wp->ifaddr, sizeof(wp->ifaddr), NULL);

    /*
        Check if this is a request from a browser on this system. This is useful to know for permitting administrative
        operations only for local access 
     */
    if (strcmp(wp->ipaddr, "127.0.0.1") == 0 || strcmp(wp->ipaddr, websIpAddr) == 0 || 
            strcmp(wp->ipaddr, websHost) == 0) {
        wp->flags |= WEBS_LOCAL;
    }
    /*
        Arrange for socketEvent to be called when read data is available
     */
#if BIT_PACK_SSL
{
    socket_t *lp = socketPtr(listenSid);
    if (lp->secure) {
        wp->flags |= WEBS_SECURE;
        if (sslUpgrade(wp) < 0) {
            error("Can't upgrade to TLS");
            return -1;
        }
    }
#endif
}
    socketCreateHandler(sid, SOCKET_READABLE, socketEvent, wp);

    /*
        Arrange for a timeout to kill hung requests
     */
    wp->timeout = gschedCallback(WEBS_TIMEOUT, websTimeout, (void *) wp);
    trace(5, "accept connection\n");
    return 0;
}


/*
    The webs socket handler.  Called in response to I/O. We just pass control to the relevant read or write handler. A
    pointer to the webs structure is passed as a (void*) in iwp.  
 */
static void socketEvent(int sid, int mask, void *iwp)
{
    Webs    *wp;

    wp = (Webs*) iwp;
    gassert(wp);

    if (! websValid(wp)) {
        return;
    }
    if (mask & SOCKET_READABLE) {
        websReadEvent(wp);
    } 
    if (mask & SOCKET_WRITABLE) {
        if (websValid(wp) && wp->writable) {
            (*wp->writable)(wp);
        }
    } 
}


/*
    Read from a connection. Return the number of bytes read if successful. This may be less than the requested "len" and
    may be zero. Return -1 for errors or EOF. Distinguish between error and EOF via socketEof().
 */
static ssize websRead(Webs *wp, char *buf, ssize len)
{
#if BIT_PACK_SSL
    if (wp->flags & WEBS_SECURE) {
        return sslRead(wp, buf, len);
    }
#endif
    return socketRead(wp->sid, buf, len);
}


/*
    The webs read handler. This is the primary read event loop. It uses a state machine to track progress while parsing
    the HTTP request.  Note: we never block as the socket is always in non-blocking mode.
 */
void websReadEvent(Webs *wp)
{
    ringq_t     *ip;
    ssize       nbytes, size, len;

    gassert(wp);
    gassert(websValid(wp));

    websSetTimeMark(wp);
    ip = &wp->input;

    while (websValid(wp)) {
        /* 
            Add one to rxLen for for a trailing null. Makes parsing much easier 
         */
        size = (wp->rxLen < 0 || wp->rxLen > BIT_LIMIT_SOCKET_BUFFER) ? BIT_LIMIT_SOCKET_BUFFER : wp->rxLen + 1;
        if ((ip->buflen - ringqLen(ip)) < size) {
            ringqGrow(ip);
        }
        nbytes = websRead(wp, (char*) ip->endp, size - 1);
        if (nbytes > 0) {
            ip->endp += nbytes;
            ringqAddNull(ip);
        }
        for (len = ringqLen(ip); len > 0; len = ringqLen(ip)) {
            websPump(wp);
            if (!websValid(wp)) {
                return;
            }
            if (ringqLen(ip) == len) {
                break;
            }
        }
        if (nbytes < 0) {
            if (wp->state < WEBS_RUNNING) {
                /* EOF or error */
                websTimeoutCancel(wp);
                socketCloseConnection(wp->sid);
                websFree(wp);
                trace(5, "Close inactive connection\n");

            } else {
                /* Request still running. Wait till complete or timer expires */
            }
            break;
        } else if (nbytes == 0 || wp->state != WEBS_CONTENT) {
            break;
        }
    }
}


static void websPump(Webs *wp)
{
    bool    canProceed;

    for (canProceed = 1; canProceed; ) {
        switch (wp->state) {
        case WEBS_BEGIN:
            canProceed = parseIncoming(wp);
            break;
        case WEBS_CONTENT:
            canProceed = processContent(wp);
            break;
        case WEBS_RUNNING:
            websHandleRequest(wp);
            return;
        }
    }
}


bool parseIncoming(Webs *wp)
{
    ringq_t     *ip;
    char      *end;

    ip = &wp->input;
    while (*ip->servp == '\r' || *ip->servp == '\n') {
        ringqGetc(ip);
    }
    if ((end = strstr((char*) wp->input.servp, "\r\n\r\n")) == 0) {
        if (ringqLen(&wp->input) >= BIT_LIMIT_HEADER) {
            websError(wp, HTTP_CODE_REQUEST_TOO_LARGE | WEBS_CLOSE, "Header too large");
        }
        return 0;
    }
    /*
        Parse the first line of the Http header
     */
    if (!parseFirstLine(wp)) {
        return 0;
    }
    if (!parseHeaders(wp)) {
        return 0;
    }
    wp->state = wp->rxLen > 0 ? WEBS_CONTENT : WEBS_RUNNING;

#if BIT_CGI
    if (strstr(wp->path, BIT_CGI_BIN) != NULL) {
        wp->flags |= WEBS_CGI;
        if (wp->flags & WEBS_POST) {
            wp->cgiStdin = websGetCgiCommName();
            if ((wp->cgifd = open(wp->cgiStdin, O_CREAT | O_WRONLY | O_BINARY, 0666)) < 0) {
                websError(wp, 400 | WEBS_CLOSE, "Can't open CGI file");
                return 0;
            }
        }
    }
#endif
    if (wp->flags & WEBS_PUT) {
        WebsStat sbuf;
        int mode, exists;
        exists = stat(wp->filename, &sbuf) == 0;
        mode = O_BINARY | O_WRONLY;
        if (!exists) {
            mode |= O_CREAT | O_TRUNC;
        }  
        wp->code = (exists && sbuf.st_mode & S_IFDIR) ? 204 : 201;
        //  MOB - can we merge docfd and putfd?
        if ((wp->putfd = open(wp->filename, mode, 0644)) < 0) {
            websError(wp, 500, "Can't create the put URI");
            return 0;
        }
    }
    return 1;
}


/*
    Parse the first line of a HTTP request
 */
static bool parseFirstLine(Webs *wp)
{
    char  *op, *proto, *protoVer, *url, *host, *query, *path, *port, *ext, *buf;
    int     testPort;

    gassert(websValid(wp));

    /*
        Determine the request type: GET, HEAD or POST
     */
    op = getToken(wp, 0);
    if (op == NULL || *op == '\0') {
        websError(wp, 400 | WEBS_CLOSE, "Bad HTTP request");
        return 0;
    }
    switch (op[0]) {
    case 'D':
        if (strcmp(op, "DELETE") == 0) {
            wp->flags |= WEBS_DELETE;
        }
        break;
    case 'G':
        if (strcmp(op, "GET") == 0) {
            wp->flags |= WEBS_GET;
        }
        break;
    case 'H':
        if (strcmp(op, "HEAD") == 0) {
            wp->flags |= WEBS_HEAD;
        }
        break;
    case 'P':
        if (strcmp(op, "POST") == 0) {
            wp->flags |= WEBS_POST;
        } else if (strcmp(op, "PUT") == 0) {
            wp->flags |= WEBS_PUT;
        }
        break;

    default:
        websError(wp, 400 | WEBS_CLOSE, "Bad request type");
        return 0;
    }
    wp->method = supper(strdup(op));
    websSetVar(wp, "REQUEST_METHOD", wp->method);

    url = getToken(wp, 0);
    if (url == NULL || *url == '\0') {
        websError(wp, 400 | WEBS_CLOSE, "Bad HTTP request");
        return 0;
    }
    if (strlen(url) > BIT_LIMIT_URI) {
        websError(wp, 400 | WEBS_CLOSE, "URI too big");
        return 0;
    }
    protoVer = getToken(wp, "\r\n");

#if BIT_DEBUG
    trace(3 | WEBS_LOG_RAW, "<<< Request\n");
#endif
    trace(2 | WEBS_LOG_RAW, "%s %s %s\n", wp->method, url, protoVer);

    /*
        Parse the URL and store all the various URL components. websUrlParse returns an allocated buffer in buf which we
        must free. We support both proxied and non-proxied requests. Proxied requests will have http://host/ at the
        start of the URL. Non-proxied will just be local path names.
     */
    host = path = port = proto = query = ext = NULL;
    if (websUrlParse(url, &buf, &host, &path, &port, &query, &proto, NULL, &ext) < 0) {
        websError(wp, 400 | WEBS_CLOSE, "Bad URL format");
        return 0;
    }
    if ((wp->path = websNormalizeUriPath(path)) == 0) {
        websError(wp, 400 | WEBS_CLOSE, "Bad URL format");
        gfree(buf);
        return 0;
    }
    wp->url = strdup(url);
    if (ext) {
        wp->ext = strdup(slower(ext));
    }
    wp->dir = strdup(websGetDocuments());
    /*
        Get a default filename
     */
    wp->filename = sfmt("%s%s", wp->dir, wp->path);

    wp->query = strdup(query);
    wp->host = strdup(host);
    wp->protocol = strdup(proto);
    wp->protoVersion = strdup(protoVer);
    if (smatch(protoVer, "HTTP/1.1")) {
        wp->flags |= WEBS_KEEP_ALIVE | WEBS_HTTP11;
    } else {
        wp->flags &= ~(WEBS_HTTP11);
    }
    if ((testPort = socketGetPort(wp->listenSid)) >= 0) {
        wp->port = testPort;
    } else {
        wp->port = atoi(port);
    }
    gfree(buf);
    return 1;
}


/*
    Parse a full request
 */
static bool parseHeaders(Webs *wp)
{
    char      *upperKey, *cp, *key, *value, *tok;
    int         count;

    gassert(websValid(wp));

    trace(3 | WEBS_LOG_RAW, "%s", wp->input.servp);
    websSetVar(wp, "HTTP_AUTHORIZATION", "");

    /* 
        Parse the header and create the Http header keyword variables
        We rewrite the header as we go for non-local requests.  NOTE: this
        modifies the header string directly and tokenizes each line with '\0'.
    */
    for (count = 0; wp->input.servp[0] != '\r'; count++) {
        if (count >= BIT_LIMIT_NUM_HEADERS) {
            websError(wp, 400 | WEBS_CLOSE, "Too many headers");
            return 0;
        }
        if ((key = getToken(wp, ":")) == NULL) {
            continue;
        }
        if ((value = getToken(wp, "\r\n")) == NULL) {
            value = "";
        }
        if (!key || !value) {
            websError(wp, 400 | WEBS_CLOSE, "Bad header format");
            return 0;
        }
        if (!key || !value) {
            websError(wp, 503 | WEBS_CLOSE, "Insufficient memory");
            return 0;
        }
        while (isspace(*value)) {
            value++;
        }
        slower(key);

        /*
            Create a variable (CGI) for each line in the header
         */
        upperKey = sfmt("HTTP_%s", key);
        for (cp = upperKey; *cp; cp++) {
            if (*cp == '-') {
                *cp = '_';
            }
        }
        supper(upperKey);
        websSetVar(wp, upperKey, value);
        gfree(upperKey);

        /*
            Track the requesting agent (browser) type
         */
        if (strcmp(key, "user-agent") == 0) {
            wp->userAgent = strdup(value);

        } else if (scaselesscmp(key, "authorization") == 0) {
            wp->authType = strdup(value);
            stok(wp->authType, " \t", &tok);
            wp->authDetails = strdup(tok);
            slower(wp->authType);

        } else if (strcmp(key, "connection") == 0) {
            slower(value);
            if (strcmp(value, "keep-alive") == 0) {
                wp->flags |= WEBS_KEEP_ALIVE;
            } else if (strcmp(value, "close") == 0) {
                wp->flags &= ~WEBS_KEEP_ALIVE;
            }

        } else if (strcmp(key, "content-length") == 0) {
            wp->rxLen = atoi(value);
            if (wp->rxLen > BIT_LIMIT_BODY) {
                websError(wp, 413 | WEBS_CLOSE, "Too big");
                return 0;
            }
            if (wp->rxLen > 0 && !smatch(wp->method, "HEAD")) {
                websSetVar(wp, "CONTENT_LENGTH", value);
                wp->rxRemaining = wp->rxLen;
            }

        } else if (strcmp(key, "content-type") == 0) {
            wp->contentType = strdup(value);
            websSetVar(wp, "CONTENT_TYPE", value);
            if (wp->flags & (WEBS_POST| WEBS_PUT)) {
                if (strstr(value, "application/x-www-form-urlencoded")) {
                    wp->flags |= WEBS_FORM;
                } else if (strstr(value, "multipart/form-data")) {
                    wp->flags |= WEBS_UPLOAD;
                }
            }

        } else if (strcmp(key, "cookie") == 0) {
            wp->flags |= WEBS_COOKIE;
            wp->cookie = strdup(value);

        } else if (strcmp(key, "if-modified-since") == 0) {
            char *cmd;
            time_t tip = 0;

            if ((cp = strchr(value, ';')) != NULL) {
                *cp = '\0';
            }
            cmd = sfmt("%s", value);

            if ((wp->since = dateParse(tip, cmd)) != 0) {
                wp->flags |= WEBS_IF_MODIFIED;
            }
            gfree(cmd);

        } else if (strcmp(key, "transfer-encoding") == 0) {
            if (scaselesscmp(value, "chunked") == 0) {
                wp->flags |= WEBS_RX_CHUNKED;
                wp->rxChunkState = WEBS_CHUNK_START;
                wp->rxRemaining = MAXINT;
            }
        }
    }
    wp->input.servp += 2;
    return 1;
}


static bool processContent(Webs *wp)
{
    ssize   nbytes;

    if ((nbytes = ringqLen(&wp->input)) == 0) {
        return 0;
    }
    wp->rxRemaining -= (nbytes - wp->rxBuffered);
#if BIT_CGI
    if (wp->cgifd >= 0 && websProcessCgiData(wp) < 0) {
        return 0;
    }
#endif
#if BIT_UPLOAD
    if ((wp->flags & WEBS_UPLOAD) && websProcessUploadData(wp) < 0) {
        return 0;
    }
#endif
    if (wp->putfd >= 0 && websProcessPutData(wp) < 0) {
        return 0;
    }
    wp->rxBuffered = ringqLen(&wp->input);

    gassert(wp->rxRemaining >= 0);
    if (wp->rxRemaining <= 0) {
        wp->state = WEBS_RUNNING;
        return 1;
    }
    return 0;
}


/*
    Basic event loop. SocketReady returns true when a socket is ready for service. SocketSelect will block until an
    event occurs. SocketProcess will actually do the servicing.
 */
void websServiceEvents(int *finished)
{
    gassert(finished);
    *finished = 0;
    while (!*finished) {
        if (socketSelect(-1, 3600 * 1000)) {
            socketProcess();
        }
        websCgiCleanup();
        grunCallbacks();
    }
}


/*
    NOTE: the vars variable is modified
 */
static void addFormVars(Webs *wp, char *vars)
{
    char  *keyword, *value, *prior, *valNew, *tok;

    keyword = stok(vars, "&", &tok);
    while (keyword != NULL) {
        if ((value = strchr(keyword, '=')) != NULL) {
            *value++ = '\0';
            websDecodeUrl(keyword, keyword, strlen(keyword));
            websDecodeUrl(value, value, strlen(value));
        } else {
            value = "";
        }
        if (*keyword) {
            /*
                If keyword has already been set, append the new value to what has been stored.
             */
            if ((prior = websGetVar(wp, keyword, NULL)) != 0) {
                valNew = sfmt("%s %s", prior, value);
                websSetVar(wp, keyword, valNew);
                gfree(valNew);
            } else {
                websSetVar(wp, keyword, value);
            }
        }
        keyword = stok(NULL, "&", &tok);
    }
}


/*
    Set the variable (CGI) environment for this request. Create variables for all standard CGI variables. Also decode
    the query string and create a variable for each name=value pair.
 */
void websSetEnv(Webs *wp)
{
    char  portBuf[8];
    char  *value;

    gassert(websValid(wp));

    websSetVar(wp, "QUERY_STRING", wp->query);
    websSetVar(wp, "GATEWAY_INTERFACE", "CGI/1.1");
    websSetVar(wp, "SERVER_HOST", websHost);
    websSetVar(wp, "SERVER_NAME", websHost);
    websSetVar(wp, "SERVER_URL", websHostUrl);
    websSetVar(wp, "REMOTE_HOST", wp->ipaddr);
    websSetVar(wp, "REMOTE_ADDR", wp->ipaddr);
    websSetVar(wp, "PATH_INFO", wp->path);
    itosbuf(portBuf, sizeof(portBuf), wp->port, 10);
    websSetVar(wp, "SERVER_PORT", portBuf);
    websSetVar(wp, "SERVER_ADDR", wp->ifaddr);
    value = sfmt("GoAhead/%s", BIT_VERSION);
    websSetVar(wp, "SERVER_SOFTWARE", value);
    gfree(value);
    websSetVar(wp, "SERVER_PROTOCOL", wp->protoVersion);

    /*
        Decode and create an environment query variable for each query keyword. We split into pairs at each '&', then
        split pairs at the '='.  Note: we rely on wp->decodedQuery preserving the decoded values in the symbol table.
     */
    if (wp->query && *wp->query) {
        wp->decodedQuery = strdup(wp->query);
        addFormVars(wp, wp->decodedQuery);
    }
    if (wp->rxLen && ringqLen(&wp->input) > 0) {
        if (wp->flags & WEBS_FORM) {
            addFormVars(wp, wp->input.servp);
            ringqGetBlkAdj(&wp->input, wp->rxLen);
            wp->rxConsumed += wp->rxLen;
        }
    }
}


/*
    Define a webs (CGI) variable for this connection. Also create in relevant scripting engines. Note: the incoming
    value may be volatile.  
 */
void websSetVar(Webs *wp, char *var, char *value)
{
    value_t      v;

    gassert(websValid(wp));

    /*
        value_instring will allocate the string if required.
     */
    if (value) {
        v = valueString(value, VALUE_ALLOCATE);
    } else {
        v = valueString("", VALUE_ALLOCATE);
    }
    symEnter(wp->vars, var, v, 0);
}


/*
 *  Return TRUE if a webs variable exists for this connection.
 */
int websTestVar(Webs *wp, char *var)
{
    WebsKey       *sp;

    gassert(websValid(wp));

    if (var == NULL || *var == '\0') {
        return 0;
    }
    if ((sp = symLookup(wp->vars, var)) == NULL) {
        return 0;
    }
    return 1;
}


/*
    Get a webs variable but return a default value if string not found.  Note, defaultGetValue can be NULL to permit
    testing existence.  
 */
char *websGetVar(Webs *wp, char *var, char *defaultGetValue)
{
    WebsKey   *sp;

    gassert(websValid(wp));
    gassert(var && *var);
 
    if ((sp = symLookup(wp->vars, var)) != NULL) {
        gassert(sp->content.type == string);
        if (sp->content.value.string) {
            return sp->content.value.string;
        } else {
            return "";
        }
    }
    return defaultGetValue;
}


/*
    Return TRUE if a webs variable is set to a given value
 */
int websCompareVar(Webs *wp, char *var, char *value)
{
    gassert(websValid(wp));
    gassert(var && *var);
 
    if (strcmp(value, websGetVar(wp, var, " __UNDEF__ ")) == 0) {
        return 1;
    }
    return 0;
}


/*
    Cancel the request timeout. Note may be called multiple times.
 */
void websTimeoutCancel(Webs *wp)
{
    gassert(websValid(wp));

    if (wp->timeout >= 0) {
        gunschedCallback(wp->timeout);
        wp->timeout = -1;
    }
}


/*
    Output a HTTP response back to the browser. If redirect is set to a URL, the browser will be sent to this location.
 */
void websResponse(Webs *wp, int code, char *message, char *redirect)
{
    ssize   len;
    
    gassert(websValid(wp));

    if ((wp->flags & WEBS_HEAD) == 0 && message && *message) {
        len = slen(message);
        websWriteHeaders(wp, code, len + 2, redirect);
        websWriteEndHeaders(wp);
        websWriteBlock(wp, message, len);
        websWriteBlock(wp, "\r\n", 2);
    } else {
        websWriteHeaders(wp, code, 0, redirect);
        websWriteEndHeaders(wp);
    }
    websDone(wp, code);
}


/*
    Redirect the user to another webs page
 */
void websRedirect(Webs *wp, char *url)
{
    char  *msgbuf, *urlbuf, *scheme, *host, *pstr;
    char    hostbuf[BIT_LIMIT_STRING];
    bool    secure, fullyQualified;
    int     port;

    gassert(websValid(wp));
    gassert(url);

    msgbuf = urlbuf = NULL;
    fullyQualified = strstr(url, "https://") || strstr(url, "https://");
    secure = strstr(url, "https://") || (wp->flags & WEBS_SECURE);
    scheme = secure ? "https" : "http";
    port = secure ? 443 : 80;

    if ((host = websGetVar(wp, "HTTP_HOST", websHostUrl)) != 0) {
        scopy(hostbuf, sizeof(hostbuf), host);
        if ((pstr = strchr(hostbuf, ':')) != 0) {
            *pstr++ = '\0';
            port = atoi(pstr);
        }
    }
    if (*url == '/') {
        url++;
    }
    if (strstr(url, "https:///")) {
        /* Short-hand for redirect to https */
        if (BIT_SSL_PORT != 443) {
            urlbuf = sfmt("%s://%s:%d/%s", scheme, hostbuf, BIT_SSL_PORT, &url[9]);
        } else {
            urlbuf = sfmt("%s://%s/%s", scheme, hostbuf, &url[9]);
        }
        url = urlbuf;
    } else if (strstr(url, "http:///")) {
        if (BIT_HTTP_PORT != 80) {
            urlbuf = sfmt("%s://%s:%d/%s", scheme, hostbuf, BIT_HTTP_PORT, &url[8]);
        } else {
            urlbuf = sfmt("%s://%s/%s", scheme, hostbuf, &url[8]);
        }
        url = urlbuf;
    } else if (!fullyQualified) {
        if (port != 80) {
            urlbuf = sfmt("%s://%s:%d/%s", scheme, hostbuf, port, url);
        } else {
            urlbuf = sfmt("%s://%s/%s", scheme, hostbuf, url);        
        }
        url = urlbuf;
    }
    msgbuf = sfmt("<html><head></head><body>\r\n\
        This document has moved to a new <a href=\"%s\">location</a>.\r\n\
        Please update your documents to reflect the new location.\r\n\
        </body></html>\r\n", url);
    websResponse(wp, 302, msgbuf, url);
    gfree(msgbuf);
    gfree(urlbuf);
}


/*  
    Escape HTML to escape defined characters (prevent cross-site scripting)
 */
char *websEscapeHtml(cchar *html)
{
    cchar   *ip;
    char    *result, *op;
    int     len;

    if (!html) {
        return strdup("");
    }
    for (len = 1, ip = html; *ip; ip++, len++) {
        if (charMatch[(int) (uchar) *ip] & WEBS_ENCODE_HTML) {
            len += 5;
        }
    }
    if ((result = galloc(len)) == 0) {
        return 0;
    }
    /*  
        Leave room for the biggest expansion
     */
    op = result;
    while (*html != '\0') {
        if (charMatch[(uchar) *html] & WEBS_ENCODE_HTML) {
            if (*html == '&') {
                strcpy(op, "&amp;");
                op += 5;
            } else if (*html == '<') {
                strcpy(op, "&lt;");
                op += 4;
            } else if (*html == '>') {
                strcpy(op, "&gt;");
                op += 4;
            } else if (*html == '#') {
                strcpy(op, "&#35;");
                op += 5;
            } else if (*html == '(') {
                strcpy(op, "&#40;");
                op += 5;
            } else if (*html == ')') {
                strcpy(op, "&#41;");
                op += 5;
            } else if (*html == '"') {
                strcpy(op, "&quot;");
                op += 6;
            } else if (*html == '\'') {
                strcpy(op, "&#39;");
                op += 5;
            } else {
                gassert(0);
            }
            html++;
        } else {
            *op++ = *html++;
        }
    }
    gassert(op < &result[len]);
    *op = '\0';
    return result;
}


/*  
    Output an error message and cleanup
 */
void websError(Webs *wp, int code, char *fmt, ...)
{
    va_list     args;
    char        *userMsg, *buf;
    char        *encoded;

    gassert(fmt);

    if (code & WEBS_CLOSE) {
        wp->flags &= ~WEBS_KEEP_ALIVE;
    }
    if (!websValid(wp)) {
        websDone(wp, code);
        return;
    }
    code &= ~WEBS_CLOSE;

    if (wp->rxRemaining && code != 200 && code != 301 && code != 302 && code != 401) {
        /* Close connection so we don't have to consume remaining content */
        wp->flags &= ~WEBS_KEEP_ALIVE;
    }
    encoded = websEscapeHtml(wp->url);
    gfree(wp->url);
    wp->url = encoded;

    va_start(args, fmt);
    userMsg = sfmtv(fmt, args);
    va_end(args);
    error("%s", userMsg);

    encoded = websEscapeHtml(userMsg);
    gfree(userMsg);
    userMsg = encoded;

    buf = sfmt("<html><head><title>Document Error: %s</title></head>\r\n\
        <body><h2>Access Error: %s</h2>\r\n\
        <p>%s</p></body></html>\r\n", websErrorMsg(code), websErrorMsg(code), userMsg);
    websResponse(wp, code, buf, NULL);
    gfree(buf);
    gfree(userMsg);
}


/*
    Return the error message for a given code
 */
char *websErrorMsg(int code)
{
    WebsError   *ep;

    for (ep = websErrors; ep->code; ep++) {
        if (code == ep->code) {
            return ep->msg;
        }
    }
    return websErrorMsg(500);
}


/*
    Trace a response header
 */
ssize websWriteHeader(Webs *wp, char *fmt, ...)
{
    va_list     vargs;
    char        *buf;
    ssize        rc;
    
    gassert(websValid(wp));
    va_start(vargs, fmt);
    if ((buf = sfmtv(fmt, vargs)) == 0) {
        error("websWrite lost data, buffer overflow");
    }
    va_end(vargs);
    gassert(buf);
    rc = 0;
    if (buf) {
        if (!(wp->flags & WEBS_RESPONSE_TRACED)) {
            wp->flags |= WEBS_RESPONSE_TRACED;
            trace(3 | WEBS_LOG_RAW, ">>> Response\n");
        }
        trace(3 | WEBS_LOG_RAW, "%s", buf);
        rc = websWriteBlock(wp, buf, strlen(buf));
        gfree(buf);
    }
    return rc;
}


/*
    Write a set of headers. Does not write the trailing blank line so callers can add more headers.
 */
void websWriteHeaders(Webs *wp, int code, ssize length, char *redirect)
{
    WebsKey     *key;
    char        *date;

    gassert(websValid(wp));

    if (!(wp->flags & WEBS_HEADERS_DONE)) {
        wp->code = code;
        if (!wp->protoVersion) {
            wp->protoVersion = sclone("HTTP/1.0");
            wp->flags &= ~WEBS_KEEP_ALIVE;
        }
        websWriteHeader(wp, "%s %d %s\r\n", wp->protoVersion, code, websErrorMsg(code));
        /*
            The Embedthis Open Source license does not permit modification of the Server header
         */
        websWriteHeader(wp, "Server: GoAhead/%s\r\n", BIT_VERSION);

        if ((date = websGetDateString(NULL)) != NULL) {
            websWriteHeader(wp, "Date: %s\r\n", date);
            gfree(date);
        }
        if (wp->authResponse) {
            websWriteHeader(wp, "WWW-Authenticate: %s\r\n", wp->authResponse);
        }
        if (wp->flags & WEBS_HEAD) {
            //  MOB use %Ld. Search for (int) everywhere
            websWriteHeader(wp, "Content-Length: %d\r\n", (int) length);                                           
        } else if (length >= 0) {                                                                                    
            websWriteHeader(wp, "Content-Length: %d\r\n", (int) length);                                           
            wp->numbytes = bytes;
        }
        wp->txLen = length;
        if (wp->txLen < 0) {
            websWriteHeader(wp, "Transfer-Encoding: chunked\r\n");
        }
        if (wp->flags & WEBS_KEEP_ALIVE) {
            websWriteHeader(wp, "Connection: keep-alive\r\n");
        } else {
            websWriteHeader(wp, "Connection: close\r\n");   
        }
        if (redirect) {
            websWriteHeader(wp, "Location: %s\r\n", redirect);
        } else if ((key = symLookup(websMime, wp->ext)) != 0) {
            websWriteHeader(wp, "Content-Type: %s\r\n", key->content.value.string);
        }
        if (wp->responseCookie) {
            websWriteHeader(wp, "Set-Cookie: %s\r\n", wp->responseCookie);
            websWriteHeader(wp, "Cache-Control: %s\r\n", "no-cache=\"set-cookie\"");
        }
    }
}


void websWriteEndHeaders(Webs *wp)
{
    /*
        By omitting the "\r\n" delimiter after the headers, chunks can emit "\r\nSize\r\n" as a single chunk delimiter
     */
    if (wp->txLen >= 0) {
        websWriteHeader(wp, "\r\n");
    }
    websFlush(wp, 0);
    wp->flags |= WEBS_HEADERS_DONE;
}


void websSetTxLength(Webs *wp, ssize length)
{
    wp->txLen = length;
}


/*
    Do formatted output to the browser. This is the public Javascript and form write procedure.
 */
ssize websWrite(Webs *wp, char *fmt, ...)
{
    va_list     vargs;
    char        *buf;
    ssize       rc;
    
    gassert(websValid(wp));

    va_start(vargs, fmt);

    buf = NULL;
    rc = 0;
    if ((buf = sfmtv(fmt, vargs)) == 0) {
        error("websWrite lost data, buffer overflow\n");
    }
    va_end(vargs);
    gassert(buf);
    if (buf) {
        rc = websWriteBlock(wp, buf, strlen(buf));
        gfree(buf);
    }
    return rc;
}


static ssize bufferOutput(Webs *wp, char *buf, ssize size) 
{
    ringq_t     *op;
    ssize       sofar, thisWrite, len, room;

    op = &wp->output;
    sofar = 0;
    while (size > 0) {
        len = ringqLen(op);
        room = op->buflen - len;
        if (len > 0 && room < size) {
            if (websFlush(wp, 0) > 0) {
                continue;
            }
            if (op->buflen < op->maxsize) {
                ringqGrow(op);
                continue;
            }
        }
        if (room == 0) {
            break;
        }
        thisWrite = min(room, size);
        ringqPutBlk(op, buf, thisWrite);
        size -= thisWrite;
        buf += thisWrite;
        sofar += thisWrite;
    }
    return sofar;
}


static ssize writeToSocket(Webs *wp, char *buf, ssize size)
{
    ssize   written;

#if BIT_PACK_SSL
    if (wp->flags & WEBS_SECURE) {
        if ((written = sslWrite(wp, buf, size)) < 0) {
            return -1;
        }
    } else 
#endif
    if ((written = socketWrite(wp->sid, buf, size)) < 0) {
        return -1;
    }
    return written;
}


/*
    Write some output using transfer chunk encoding if required
 */
static ssize writeChunked(Webs *wp, char *buf, ssize size)
{
    ssize   written;

    written = 0;
    if (wp->txLen > 0 || !(wp->flags & WEBS_HEADERS_DONE)) {
        if (size == 0) {
            return 0;
        }
        /* Know the content length, no need for chunking */
        return writeToSocket(wp, buf, size);
    }
    while (1) {
        switch (wp->txChunkState) {
        default:
        case WEBS_CHUNK_START:
            if (size > 0) {
                fmt(wp->txChunkPrefix, sizeof(wp->txChunkPrefix), "\r\n%x\r\n", size);
            } else {
                scopy(wp->txChunkPrefix, sizeof(wp->txChunkPrefix), "\r\n0\r\n\r\n");
            }
            wp->txChunkPrefixLen = slen(wp->txChunkPrefix);
            wp->txChunkPrefixNext = wp->txChunkPrefix;
            wp->txChunkLen = size;
            wp->txChunkState = WEBS_CHUNK_HEADER;
            break;

        case WEBS_CHUNK_HEADER:
            if ((written = writeToSocket(wp, wp->txChunkPrefixNext, wp->txChunkPrefixLen)) < 0) {
                return -1;
            } else {
                wp->txChunkPrefixNext += written;
                wp->txChunkPrefixLen -= written;
                if (wp->txChunkPrefixLen <= 0 && size > 0) {
                    wp->txChunkState = WEBS_CHUNK_DATA;
                } else {
                    return 0;
                }
            }
            break;

        case WEBS_CHUNK_DATA:
            if ((written = writeToSocket(wp, buf, wp->txChunkLen)) < 0) {
                return -1;
            }
            wp->txChunkLen -= written;
            if (wp->txChunkLen <= 0) {
                wp->txChunkState = WEBS_CHUNK_START;
            }
            if (wp->txChunkLen <= 0) {
                return size;
            }
        }
    }
}


ssize websFlush(Webs *wp, int final)
{
    ringq_t     *op;
    ssize       written, size;

    op = &wp->output;
    size = ringqLen(&wp->output);
    if (size > 0) {
        if ((written = writeChunked(wp, op->servp, size)) < 0) {
            return -1;
        }
        ringqGetBlkAdj(op, written);
    }
    ringqCompact(op);
    /*
        Write chunk trailer
     */
    if (final && wp->txLen < 0) {
        writeChunked(wp, NULL, 0);
    }
    return written;
}


/*
    Write a block of data of length to the user's browser. Output is buffered and flushed via websFlush.
 */
ssize websWriteBlock(Webs *wp, char *buf, ssize size)
{
    ssize   len, written;

    gassert(wp);
    gassert(websValid(wp));
    gassert(buf);
    gassert(size >= 0);

    written = len = 0;
    while (size > 0) {  
        if ((len = bufferOutput(wp, buf, size)) < 0) {
            return -1;
        }
        size -= len;
        buf += len;
        written += len;
    }
    return written;
}


/*
    Write a block of data of length "size" to the user's browser. Unbuffered write.
    WARNING: If data is buffered, this will do a blocking flush first. To avoid this, call websFlush() manually
    and check the results.
 */
ssize websWriteRaw(Webs *wp, char *buf, ssize size)
{
    ssize   written;
    int     prior;
    
    /*
        Flush any buffered data to ensure data remains in sequence. 
        WARNING: Must do this blocking to ensure all data is written.
     */
    prior = socketSetBlock(wp->sid, 1);
    written = websFlush(wp, 0);
    socketSetBlock(wp->sid, prior);
    if (written < 0) {
        return written;
    }
    return writeToSocket(wp, buf, size);
}


/*
    Decode a URL (or part thereof). Allows insitu decoding.
 */
void websDecodeUrl(char *decoded, char *token, ssize len)
{
    char  *ip,  *op;
    int     num, i, c;
    
    gassert(decoded);
    gassert(token);

    if (len < 0) {
        len = strlen(token);
    }
    op = decoded;
    for (ip = token; *ip && len > 0; ip++, op++) {
        if (*ip == '+') {
            *op = ' ';
        } else if (*ip == '%' && isxdigit(ip[1]) && isxdigit(ip[2])) {
            /*
                Convert %nn to a single character
             */
            ip++;
            for (i = 0, num = 0; i < 2; i++, ip++) {
                c = tolower(*ip);
                if (c >= 'a' && c <= 'f') {
                    num = (num * 16) + 10 + c - 'a';
                } else {
                    num = (num * 16) + c - '0';
                }
            }
            *op = (char) num;
            ip--;

        } else {
            *op = *ip;
        }
        len--;
    }
    *op = '\0';
}


#if BIT_ACCESS_LOG
/*
    Output a log message in Common Log Format: See http://httpd.apache.org/docs/1.3/logs.html#common
 */
static void logRequest(Webs *wp, int code)
{
    char      *buf, timeStr[28], zoneStr[6], dataStr[16];
    char        *abuf;
    ssize       len;
    time_t      timer;
    struct tm   localt;
#if WINDOWS
    DWORD       dwRet;
    TIME_ZONE_INFORMATION tzi;
#endif

    time(&timer);
#if WINDOWS
    localtime_s(&localt, &timer);
#else
    localtime_r(&timer, &localt);
#endif
    strftime(timeStr, sizeof(timeStr), "%d/%b/%Y:%H:%M:%S", &localt); 
    timeStr[sizeof(timeStr) - 1] = '\0';
#if WINDOWS
    dwRet = GetTimeZoneInformation(&tzi);
    fmt(zoneStr, sizeof(zoneStr), "%+03d00", -(int)(tzi.Bias/60));
#elif !VXWORKS
    fmt(zoneStr, sizeof(zoneStr), "%+03d00", (int)(localt.tm_gmtoff/3600));
#else
    zoneStr[0] = '\0';
#endif
    zoneStr[sizeof(zoneStr) - 1] = '\0';
    if (wp->written != 0) {
        fmt(dataStr, sizeof(dataStr), "%d", (int) wp->written);
        dataStr[sizeof(dataStr) - 1] = '\0';
    } else {
        dataStr[0] = '-'; dataStr[1] = '\0';
    }
    buf = NULL;
    buf = sfmt("%s - %s [%s %s] \"%s %s %s\" %d %s\n", 
        wp->ipaddr,
        wp->username == NULL ? "-" : wp->username,
        timeStr, zoneStr,
        wp->flags & WEBS_POST? "POST" : (wp->flags & WEBS_HEAD? "HEAD" : "GET"), wp->path,
        wp->protoVersion, code, dataStr);
    len = strlen(buf);
    abuf = gallocUniToAsc(buf, len+1);
    write(accessFd, abuf, len);
    gfree(buf);
    gfree(abuf);
}
#endif


/*
    Request timeout. The timeout triggers if we have not read any data from the users browser in the last WEBS_TIMEOUT
    period. If we have heard from the browser, simply re-issue the timeout.
 */
void websTimeout(void *arg, int id)
{
    Webs        *wp;
    time_t      tm, delay;

    wp = (Webs*) arg;
    gassert(websValid(wp));

    tm = getTimeSinceMark(wp) * 1000;
    if (websDebug) {
        greschedCallback(id, (int) WEBS_TIMEOUT);
        return;
    } else if (tm >= WEBS_TIMEOUT) {
        gunschedCallback(id);
        wp->timeout = -1;
        websDone(wp, 404);
    } else {
        delay = WEBS_TIMEOUT - tm;
        gassert(delay > 0);
        greschedCallback(id, (int) delay);
    }
}


char *websGetHost()
{
    return websHost;
}


char *websGetIpAddrUrl()
{
    return websIpAddrUrl;
}


char *websGetHostUrl()
{
    return websHostUrl;
}


ssize websGetRequestBytes(Webs *wp)
{
    gassert(websValid(wp));
    return wp->numbytes;
}


char *websGetRequestDir(Webs *wp)
{
    gassert(websValid(wp));

    if (wp->dir == NULL) {
        return "";
    }
    return wp->dir;
}


int websGetRequestFlags(Webs *wp)
{
    gassert(websValid(wp));

    return wp->flags;
}


char *websGetRequestIpAddr(Webs *wp)
{
    gassert(websValid(wp));

    return wp->ipaddr;
}


char *websGetRequestFilename(Webs *wp)
{
    gassert(websValid(wp));

    //  MOB - unify
#if BIT_ROM
    return wp->path;
#else
    return wp->filename;
#endif
}


//  MOB DEPRECATE - #define to wp->path
char *websGetRequestPath(Webs *wp)
{
    gassert(websValid(wp));

    if (wp->path == NULL) {
        return "";
    }
    return wp->path;
}


//  MOB DEPRECATE 
char *websGetRequestPassword(Webs *wp)
{
    gassert(websValid(wp));
    return wp->password;
}


char *websGetRequestUserName(Webs *wp)
{
    gassert(websValid(wp));
    return wp->username;
}


ssize websGetRequestWritten(Webs *wp)
{
    gassert(websValid(wp));
    return wp->written;
}


static int setLocalHost()
{
    struct in_addr  intaddr;
    char            host[128], *ipaddr;

    if (gethostname(host, sizeof(host)) < 0) {
        error("Can't get hostname");
        return -1;
    }
#if VXWORKS
    intaddr.s_addr = (ulong) hostGetByName(host);
    ipaddr = inet_ntoa(intaddr);
    websSetIpAddr(ipaddr);
    websSetHost(ipaddr);
    free(ipaddr);
#elif ECOS
    ipaddr = inet_ntoa(eth0_bootp_data.bp_yiaddr);
    websSetIpAddr(ipaddr);
    websSetHost(ipaddr);
#else
{
    struct hostent  *hp;
    if ((hp = gethostbyname(host)) == NULL) {
        error("Can't get host address");
        return -1;
    }
    memcpy((char *) &intaddr, (char *) hp->h_addr_list[0], (size_t) hp->h_length);
    ipaddr = inet_ntoa(intaddr);
    websSetIpAddr(ipaddr);
    websSetHost(ipaddr);
}
#endif
    return 0;
}


//  MOB - review if all these APIs are needed
void websSetHost(char *host)
{
    strncpy(websHost, host, TSZ(websHost));
}


void websSetHostUrl(char *url)
{
    gassert(url && *url);

    gfree(websHostUrl);
    websHostUrl = strdup(url);
}


void websSetIpAddr(char *ipaddr)
{
    gassert(ipaddr && *ipaddr);
    strncpy(websIpAddr, ipaddr, TSZ(websIpAddr));
}


#if UNUSED && KEEP
void websSetRequestFilename(Webs *wp, char *filename)
{
    gassert(websValid(wp));
    gassert(filename && *filename);

    if (wp->filename) {
        gfree(wp->filename);
    }
    wp->filename = strdup(filename);
    websSetVar(wp, "PATH_TRANSLATED", wp->filename);
}
#endif


/*
    Update the URL path and the directory containing the web page
 */
void websSetRequestPath(Webs *wp, char *dir, char *path)
{
    char  *tmp;

    gassert(websValid(wp));

    if (dir) { 
        tmp = wp->dir;
        wp->dir = strdup(dir);
        if (tmp) {
            gfree(tmp);
        }
    }
    if (path) {
        tmp = wp->path;
        wp->path = strdup(path);
        websSetVar(wp, "PATH_INFO", wp->path);
        if (tmp) {
            gfree(tmp);
        }
    }
}


void websRewriteRequest(Webs *wp, char *url)
{
    gfree(wp->url);
    wp->url = strdup(url);
    websSetRequestPath(wp, NULL, wp->url);
    gfree(wp->filename);
    wp->filename = sfmt("%s%s", wp->dir, wp->path);
}


void websSetRequestWritten(Webs *wp, ssize written)
{
    gassert(websValid(wp));
    wp->written = written;
}


bool websValid(Webs *wp)
{
    int     wid;

    for (wid = 0; wid < websMax; wid++) {
        if (wp == webs[wid]) {
            return 1;
        }
    }
    return 0;
}


bool websComplete(Webs *wp) 
{
    return !websValid(wp) || wp->state == WEBS_BEGIN;
}


/*
    Build an ASCII time string.  If sbuf is NULL we use the current time, else we use the last modified time of sbuf;
 */
char *websGetDateString(WebsFileInfo *sbuf)
{
    char  *cp, *r;
    time_t  now;

    if (sbuf == NULL) {
        time(&now);
    } else {
        now = sbuf->mtime;
    }
    if ((cp = ctime(&now)) != NULL) {
        cp[strlen(cp) - 1] = '\0';
        r = strdup(cp);
        return r;
    }
    return NULL;
}


/*
    Mark time. Set a timestamp so that, later, we can return the number of seconds since we made the mark. Note that the
    mark my not be a "real" time, but rather a relative marker.
 */
void websSetTimeMark(Webs *wp)
{
    wp->timestamp = time(0);
}


/*
    Get the number of seconds since the last mark.
 */
static time_t getTimeSinceMark(Webs *wp)
{
    return time(0) - wp->timestamp;
}


//  MOB - move all into a date.c
/*  
    These functions are intended to closely mirror the syntax for HTTP-date 
    from RFC 2616 (HTTP/1.1 spec).  This code was submitted by Pete Berstrom.
    
    RFC1123Date = wkday "," SP date1 SP time SP "GMT"
    RFC850Date  = weekday "," SP date2 SP time SP "GMT"
    ASCTimeDate = wkday SP date3 SP time SP 4DIGIT
  
    Each of these functions tries to parse the value and update the index to 
    the point it leaves off parsing.
 */

typedef enum { JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC } MonthEnumeration;
typedef enum { SUN, MON, TUE, WED, THU, FRI, SAT } WeekdayEnumeration;

/*  
    Parse an N-digit value
 */

static int parseNDIGIT(char *buf, int digits, int *index) 
{
    int tmpIndex, returnValue;

    returnValue = 0;
    for (tmpIndex = *index; tmpIndex < *index+digits; tmpIndex++) {
        if (isdigit(buf[tmpIndex])) {
            returnValue = returnValue * 10 + (buf[tmpIndex] - '0');
        }
    }
    *index = tmpIndex;
    return returnValue;
}


/*
    Return an index into the month array
 */

static int parseMonth(char *buf, int *index) 
{
    /*  
        "Jan" | "Feb" | "Mar" | "Apr" | "May" | "Jun" | 
        "Jul" | "Aug" | "Sep" | "Oct" | "Nov" | "Dec"
     */
    int tmpIndex, returnValue;
    returnValue = -1;
    tmpIndex = *index;

    switch (buf[tmpIndex]) {
        case 'A':
            switch (buf[tmpIndex+1]) {
                case 'p':
                    returnValue = APR;
                    break;
                case 'u':
                    returnValue = AUG;
                    break;
            }
            break;
        case 'D':
            returnValue = DEC;
            break;
        case 'F':
            returnValue = FEB;
            break;
        case 'J':
            switch (buf[tmpIndex+1]) {
                case 'a':
                    returnValue = JAN;
                    break;
                case 'u':
                    switch (buf[tmpIndex+2]) {
                        case 'l':
                            returnValue = JUL;
                            break;
                        case 'n':
                            returnValue = JUN;
                            break;
                    }
                    break;
            }
            break;
        case 'M':
            switch (buf[tmpIndex+1]) {
                case 'a':
                    switch (buf[tmpIndex+2]) {
                        case 'r':
                            returnValue = MAR;
                            break;
                        case 'y':
                            returnValue = MAY;
                            break;
                    }
                    break;
            }
            break;
        case 'N':
            returnValue = NOV;
            break;
        case 'O':
            returnValue = OCT;
            break;
        case 'S':
            returnValue = SEP;
            break;
    }
    if (returnValue >= 0) {
        *index += 3;
    }
    return returnValue;
}


/* 
    Parse a year value (either 2 or 4 digits)
 */
static int parseYear(char *buf, int *index) 
{
    int tmpIndex, returnValue;

    tmpIndex = *index;
    returnValue = parseNDIGIT(buf, 4, &tmpIndex);

    if (returnValue >= 0) {
        *index = tmpIndex;
    } else {
        returnValue = parseNDIGIT(buf, 2, &tmpIndex);
        if (returnValue >= 0) {
            /*
                Assume that any year earlier than the start of the epoch for time_t (1970) specifies 20xx
             */
            if (returnValue < 70) {
                returnValue += 2000;
            } else {
                returnValue += 1900;
            }
            *index = tmpIndex;
        }
    }
    return returnValue;
}


/* 
    The formulas used to build these functions are from "Calendrical Calculations", by Nachum Dershowitz, Edward M.
    Reingold, Cambridge University Press, 1997.  
 */

//  MOB - move to header
#include <math.h>

//  MOB - static
const int GregorianEpoch = 1;


/*
    Determine if year is a leap year
 */
int GregorianLeapYearP(long year) 
{
    long    tmp;
    
    tmp = year % 400;
    return (year % 4 == 0) && (tmp != 100) && (tmp != 200) && (tmp != 300);
}


/*
    Return the fixed date from the gregorian date
 */
long FixedFromGregorian(long month, long day, long year) 
{
    long fixedDate;

    fixedDate = (long)(GregorianEpoch - 1 + 365 * (year - 1) + 
        floor((year - 1) / 4.0) -
        floor((double)(year - 1) / 100.0) + 
        floor((double)(year - 1) / 400.0) + 
        floor((367.0 * ((double)month) - 362.0) / 12.0));

    if (month <= 2) {
        fixedDate += 0;
    } else if (GregorianLeapYearP(year)) {
        fixedDate += -1;
    } else {
        fixedDate += -2;
    }
    fixedDate += day;
    return fixedDate;
}


/*
    Return the gregorian year from a fixed date
 */
long GregorianYearFromFixed(long fixedDate) 
{
    long result, d0, n400, d1, n100, d2, n4, d3, n1, year;

    d0 =    fixedDate - GregorianEpoch;
    n400 =  (long)(floor((double)d0 / (double)146097));
    d1 =    d0 % 146097;
    n100 =  (long)(floor((double)d1 / (double)36524));
    d2 =    d1 % 36524;
    n4 =    (long)(floor((double)d2 / (double)1461));
    d3 =    d2 % 1461;
    n1 =    (long)(floor((double)d3 / (double)365));
    year =  400 * n400 + 100 * n100 + 4 * n4 + n1;

    if ((n100 == 4) || (n1 == 4)) {
        result = year;
    } else {
        result = year + 1;
    }
    return result;
}


/* 
    Returns the Gregorian date from a fixed date (not needed for this use, but included for completeness)
 */
#if UNUSED && KEEP
void GregorianFromFixed(long fixedDate, long *month, long *day, long *year) 
{
    long priorDays, correction;

    *year =         GregorianYearFromFixed(fixedDate);
    priorDays =     fixedDate - FixedFromGregorian(1, 1, *year);

    if (fixedDate < FixedFromGregorian(3,1,*year)) {
        correction = 0;
    } else if (true == GregorianLeapYearP(*year)) {
        correction = 1;
    } else {
        correction = 2;
    }
    *month = (long)(floor((12.0 * (double)(priorDays + correction) + 373.0) / 367.0));
    *day = fixedDate - FixedFromGregorian(*month, 1, *year);
}
#endif


/* 
    Returns the difference between two Gregorian dates
 */
long GregorianDateDifferenc(long month1, long day1, long year1, long month2, long day2, long year2) 
{
    return FixedFromGregorian(month2, day2, year2) - FixedFromGregorian(month1, day1, year1);
}


/*
    Return the number of seconds into the current day
 */
#define SECONDS_PER_DAY 24*60*60

static int parseTime(char *buf, int *index) 
{
    /*  
        Format of buf is - 2DIGIT ":" 2DIGIT ":" 2DIGIT
     */
    int returnValue, tmpIndex, hourValue, minuteValue, secondValue;

    hourValue = minuteValue = secondValue = -1;
    returnValue = -1;
    tmpIndex = *index;

    hourValue = parseNDIGIT(buf, 2, &tmpIndex);

    if (hourValue >= 0) {
        tmpIndex++;
        minuteValue = parseNDIGIT(buf, 2, &tmpIndex);
        if (minuteValue >= 0) {
            tmpIndex++;
            secondValue = parseNDIGIT(buf, 2, &tmpIndex);
        }
    }
    if ((hourValue >= 0) && (minuteValue >= 0) && (secondValue >= 0)) {
        returnValue = (((hourValue * 60) + minuteValue) * 60) + secondValue;
        *index = tmpIndex;
    }
    return returnValue;
}


/*
    Return the equivalent of time() given a gregorian date
 */
static time_t dateToTimet(int year, int month, int day) 
{
    long dayDifference;

    dayDifference = FixedFromGregorian(month + 1, day, year) - FixedFromGregorian(1, 1, 1970);
    return dayDifference * SECONDS_PER_DAY;
}


/*
    Return the number of seconds between Jan 1, 1970 and the parsed date (corresponds to documentation for time() function)
 */
static time_t parseDate1or2(char *buf, int *index) 
{
    /*  
        Format of buf is either
        2DIGIT SP month SP 4DIGIT
        or
        2DIGIT "-" month "-" 2DIGIT
     */
    int     dayValue, monthValue, yearValue, tmpIndex;
    time_t  returnValue;

    returnValue = (time_t) -1;
    tmpIndex = *index;

    dayValue = monthValue = yearValue = -1;

    if (buf[tmpIndex] == ',') {
        /* 
            Skip over the ", " 
         */
        tmpIndex += 2; 

        dayValue = parseNDIGIT(buf, 2, &tmpIndex);
        if (dayValue >= 0) {
            /*
                Skip over the space or hyphen
             */
            tmpIndex++; 
            monthValue = parseMonth(buf, &tmpIndex);
            if (monthValue >= 0) {
                /*
                    Skip over the space or hyphen
                 */
                tmpIndex++; 
                yearValue = parseYear(buf, &tmpIndex);
            }
        }

        if ((dayValue >= 0) &&
            (monthValue >= 0) &&
            (yearValue >= 0)) {
            if (yearValue < 1970) {
                /*              
                    Allow for Microsoft IE's year 1601 dates 
                 */
                returnValue = 0; 
            } else {
                returnValue = dateToTimet(yearValue, monthValue, dayValue);
            }
            *index = tmpIndex;
        }
    }
    
    return returnValue;
}


/*
    Return the number of seconds between Jan 1, 1970 and the parsed date
 */
static time_t parseDate3Time(char *buf, int *index) 
{
    /*
        Format of buf is month SP ( 2DIGIT | ( SP 1DIGIT ))
     */
    int     dayValue, monthValue, yearValue, timeValue, tmpIndex;
    time_t  returnValue;

    returnValue = (time_t) -1;
    tmpIndex = *index;

    dayValue = monthValue = yearValue = timeValue = -1;

    monthValue = parseMonth(buf, &tmpIndex);
    if (monthValue >= 0) {
        /*      
            Skip over the space 
         */
        tmpIndex++; 
        if (buf[tmpIndex] == ' ') {
            /*
                Skip over this space too 
             */
            tmpIndex++; 
            dayValue = parseNDIGIT(buf, 1, &tmpIndex);
        } else {
            dayValue = parseNDIGIT(buf, 2, &tmpIndex);
        }
        /*      
            Now get the time and time SP 4DIGIT
         */
        timeValue = parseTime(buf, &tmpIndex);
        if (timeValue >= 0) {
            /*          
                Now grab the 4DIGIT year value
             */
            yearValue = parseYear(buf, &tmpIndex);
        }
    }

    if ((dayValue >= 0) && (monthValue >= 0) && (yearValue >= 0)) {
        returnValue = dateToTimet(yearValue, monthValue, dayValue);
        returnValue += timeValue;
        *index = tmpIndex;
    }
    return returnValue;
}


//  MOB - macro and rename
static int bufferIndexIncrementGivenNTest(char *buf, int testIndex, char testChar, int foundIncrement, int notfoundIncrement) 
{
    if (buf[testIndex] == testChar) {
        return foundIncrement;
    }
    return notfoundIncrement;
}


/*
    Return an index into a logical weekday array
 */
static int parseWeekday(char *buf, int *index) 
{
    /*  
        Format of buf is either
            "Mon" | "Tue" | "Wed" | "Thu" | "Fri" | "Sat" | "Sun"
        or
            "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday"
     */
    int tmpIndex, returnValue;

    returnValue = -1;
    tmpIndex = *index;

    switch (buf[tmpIndex]) {
        case 'F':
            returnValue = FRI;
            *index += bufferIndexIncrementGivenNTest(buf, tmpIndex+3, 'd', sizeof("Friday"), 3);
            break;
        case 'M':
            returnValue = MON;
            *index += bufferIndexIncrementGivenNTest(buf, tmpIndex+3, 'd', sizeof("Monday"), 3);
            break;
        case 'S':
            switch (buf[tmpIndex+1]) {
                case 'a':
                    returnValue = SAT;
                    *index += bufferIndexIncrementGivenNTest(buf, tmpIndex+3, 'u', sizeof("Saturday"), 3);
                    break;
                case 'u':
                    returnValue = SUN;
                    *index += bufferIndexIncrementGivenNTest(buf, tmpIndex+3, 'd', sizeof("Sunday"), 3);
                    break;
            }
            break;
        case 'T':
            switch (buf[tmpIndex+1]) {
                case 'h':
                    returnValue = THU;
                    *index += bufferIndexIncrementGivenNTest(buf, tmpIndex+3, 'r', sizeof("Thursday"), 3);
                    break;
                case 'u':
                    returnValue = TUE;
                    *index += bufferIndexIncrementGivenNTest(buf, tmpIndex+3, 's', sizeof("Tuesday"), 3);
                    break;
            }
            break;
        case 'W':
            returnValue = WED;
            *index += bufferIndexIncrementGivenNTest(buf, tmpIndex+3, 'n', sizeof("Wednesday"), 3);
            break;
    }
    return returnValue;
}


/*
        Parse the date and time string.
 */
static time_t dateParse(time_t tip, char *cmd)
{
    int index, tmpIndex, weekday, timeValue;
    time_t parsedValue, dateValue;

    parsedValue = (time_t) 0;
    index = timeValue = 0;
    weekday = parseWeekday(cmd, &index);

    if (weekday >= 0) {
        tmpIndex = index;
        dateValue = parseDate1or2(cmd, &tmpIndex);
        if (dateValue >= 0) {
            index = tmpIndex + 1;
            /*
                One of these two forms is being used
                wkday "," SP date1 SP time SP "GMT"
                weekday "," SP date2 SP time SP "GMT"
             */
            timeValue = parseTime(cmd, &index);
            if (timeValue >= 0) {
                /*              
                    Now match up that "GMT" string for completeness
                    Compute the final value if there were no problems in the parse
                 */
                if ((weekday >= 0) &&
                    (dateValue >= 0) &&
                    (timeValue >= 0)) {
                    parsedValue = dateValue + timeValue;
                }
            }
        } else {
            /* 
                Try the other form - wkday SP date3 SP time SP 4DIGIT
             */
            tmpIndex = index;
            parsedValue = parseDate3Time(cmd, &tmpIndex);
        }
    }

    return parsedValue;
}


/*
    Parse the URL. A buffer is allocated to store the parsed URL in *pbuf. This must be freed by the caller. NOTE: tag
    is not yet fully supported.  
 */
int websUrlParse(char *url, char **pbuf, char **phost, char **ppath, char **pport, char **pquery, 
        char **pproto, char **ptag, char **pext)
{
    char      *tok, *cp, *host, *path, *port, *proto, *tag, *query, *ext;
    char      *hostbuf, *portbuf, *buf;
    ssize       len, ulen;
    int         c;

    gassert(url);
    gassert(pbuf);

    ulen = strlen(url);
    /*
        We allocate enough to store separate hostname and port number fields.  As there are 3 strings in the one buffer,
        we need room for 3 null chars.  We allocate WEBS_MAX_PORT_LEN char's for the port number.  
     */
    len = ulen * 2 + WEBS_MAX_PORT_LEN + 3;
    if ((buf = galloc(len * sizeof(char))) == NULL) {
        return -1;
    }
    memset(buf, 0, len * sizeof(char));
    portbuf = &buf[len - WEBS_MAX_PORT_LEN - 1];
    hostbuf = &buf[ulen+1];
    websDecodeUrl(buf, url, ulen);

    /*
        Convert the current listen port to a string. We use this if the URL has no explicit port setting
     */
    url = buf;
    port = portbuf;
    path = "/";
    proto = "http";
    host = "localhost";
    query = "";
    ext = 0;
    tag = "";

    if (strncmp(url, "http://", 7) == 0) {
        tok = &url[7];
        tok[-3] = '\0';
        proto = url;
        host = tok;
        for (cp = tok; *cp; cp++) {
            if (*cp == '/') {
                break;
            }
            if (*cp == ':') {
                *cp++ = '\0';
                port = cp;
                tok = cp;
            }
        }
        if ((cp = strchr(tok, '/')) != NULL) {
            /*
                If a full URL is supplied, we need to copy the host and port portions into static buffers.
             */
            c = *cp;
            *cp = '\0';
            strncpy(hostbuf, host, ulen);
            strncpy(portbuf, port, WEBS_MAX_PORT_LEN);
            *cp = c;
            host = hostbuf;
            port = portbuf;
            path = cp;
            tok = cp;
        }
    } else {
        path = url;
        tok = url;
    }
    /*
        Parse the query string
     */
    if ((cp = strchr(tok, '?')) != NULL) {
        *cp++ = '\0';
        query = cp;
        path = tok;
        tok = query;
    } 

    /*
        Parse the fragment identifier
     */
    if ((cp = strchr(tok, '#')) != NULL) {
        *cp++ = '\0';
        if (*query == 0) {
            path = tok;
        }
    }
    if (pext) {
        if ((cp = strrchr(path, '.')) != NULL) {
            //  MOB - review. See httpCreateUri
            const char* garbage = "/\\";
            ssize length = strcspn(cp, garbage);
            ssize glen = strspn(cp + length, garbage);
            ssize ok = (cp[length + glen] == '\0');
            if (ok) {
                cp[length] = '\0';
                //  MOB - skip "."
#if BIT_WIN_LIKE
                slower(cp);            
                //  MOB - don't map extension case. Those who test should use caseless test
#endif
                ext = cp;
            }
        }
    }
    /*
        Pass back the fields requested (if not NULL)
     */
    if (phost)
        *phost = host;
    if (ppath)
        *ppath = path;
    if (pport)
        *pport = port;
    if (pproto)
        *pproto = proto;
    if (pquery)
        *pquery = query;
    if (ptag)
        *ptag = tag;
    if (pext)
        *pext = ext;
    *pbuf = buf;
    return 0;
}


/*
    Normalize a URI path to remove redundant "./" and cleanup "../" and make separator uniform. Does not make an abs path.
    It does not map separators nor change case. 
 */
char *websNormalizeUriPath(char *pathArg)
{
    char    *dupPath, *path, *sp, *dp, *mark, **segments;
    int     firstc, j, i, nseg, len;

    if (pathArg == 0 || *pathArg == '\0') {
        return "";
    }
    len = (int) slen(pathArg);
    if ((dupPath = galloc(len + 2)) == 0) {
        return NULL;
    }
    strcpy(dupPath, pathArg);

    if ((segments = galloc(sizeof(char*) * (len + 1))) == 0) {
        return NULL;
    }
    nseg = len = 0;
    firstc = *dupPath;
    for (mark = sp = dupPath; *sp; sp++) {
        if (*sp == '/') {
            *sp = '\0';
            while (sp[1] == '/') {
                sp++;
            }
            segments[nseg++] = mark;
            len += (int) (sp - mark);
            mark = sp + 1;
        }
    }
    segments[nseg++] = mark;
    len += (int) (sp - mark);
    for (j = i = 0; i < nseg; i++, j++) {
        sp = segments[i];
        if (sp[0] == '.') {
            if (sp[1] == '\0')  {
                if ((i+1) == nseg) {
                    segments[j] = "";
                } else {
                    j--;
                }
            } else if (sp[1] == '.' && sp[2] == '\0')  {
                if (i == 1 && *segments[0] == '\0') {
                    j = 0;
                } else if ((i+1) == nseg) {
                    if (--j >= 0) {
                        segments[j] = "";
                    }
                } else {
                    j = max(j - 2, -1);
                }
            }
        } else {
            segments[j] = segments[i];
        }
    }
    nseg = j;
    gassert(nseg >= 0);
    if ((path = galloc(len + nseg + 1)) != 0) {
        for (i = 0, dp = path; i < nseg; ) {
            strcpy(dp, segments[i]);
            len = (int) slen(segments[i]);
            dp += len;
            if (++i < nseg || (nseg == 1 && *segments[0] == '\0' && firstc == '/')) {
                *dp++ = '/';
            }
        }
        *dp = '\0';
    }
    return path;
}


/*
    Open a web page. filename is the local filename. path is the URL path name.

 */
int websPageOpen(Webs *wp, char *filename, char *path, int mode, int perm)
{
    gassert(websValid(wp));
#if BIT_ROM
    return websRomPageOpen(wp, path, mode, perm);
#else
    return (wp->docfd = open(filename, mode, perm));
#endif
}


void websPageClose(Webs *wp)
{
    gassert(websValid(wp));

#if BIT_ROM
    websRomPageClose(wp->docfd);
#else
    if (wp->docfd >= 0) {
        close(wp->docfd);
        wp->docfd = -1;
    }
#endif
}


/*
    Stat a web page filename is the local filename. path is the URL path name.
 */
int websPageStat(Webs *wp, char *filename, char *path, WebsFileInfo *sbuf)
{
#if BIT_ROM
    return websRomPageStat(path, sbuf);
#else
    WebsStat    s;

    if (stat(filename, &s) < 0) {
        return -1;
    }
    sbuf->size = (ssize) s.st_size;
    sbuf->mtime = s.st_mtime;
    sbuf->isDir = s.st_mode & S_IFDIR;
    return 0;
#endif
}


int websPageIsDirectory(char *filename)
{
#if BIT_ROM
    WebsFileInfo    sbuf;

    if (websRomPageStat(filename, &sbuf) >= 0) {
        return(sbuf.isDir);
    } else {
        return 0;
    }
#else
    WebsStat    sbuf;

    if (stat(filename, &sbuf) >= 0) {
        return(sbuf.st_mode & S_IFDIR);
    } else {
        return 0;
    }
#endif
}


/*
    Read a web page. Returns the number of _bytes_ read. len is the size of buf, in bytes.
 */
ssize websPageReadData(Webs *wp, char *buf, ssize nBytes)
{

#if BIT_ROM
    gassert(websValid(wp));
    return websRomPageReadData(wp, buf, nBytes);
#else
    gassert(websValid(wp));
    return read(wp->docfd, buf, (int) nBytes);
#endif
}


/*
    Move file pointer offset bytes.
 */
void websPageSeek(Webs *wp, WebsFilePos offset)
{
    gassert(websValid(wp));

#if BIT_ROM
    websRomPageSeek(wp, offset, SEEK_CUR);
#else
    lseek(wp->docfd, (long) offset, SEEK_CUR);
#endif
}


void websSetCookie(Webs *wp, char *name, char *value, char *path, char *cookieDomain, time_t lifespan, int flags)
{
    time_t  when;
    char    *cp, *expiresAtt, *expires, *domainAtt, *domain, *secure, *httponly, *cookie, *old;

    if (path == 0) {
        path = "/";
    }
    if (!cookieDomain) {
        domain = strdup(websGetVar(wp, "HTTP_HOST", ""));
        if ((cp = strchr(domain, ':')) != 0) {
            /* Strip port */
            *cp = '\0';
        }
        if (*domain && domain[strlen(domain) - 1] == '.') {
            /* Cleanup bonjour addresses with trailing dot */
            domain[strlen(domain) - 1] = '\0';
        }
    } else {
        domain = strdup(cookieDomain);
    }
    domainAtt = domain ? "; domain=" : "";
    if (domain && !strchr(domain, '.')) {
        old = domain;
        domain = sfmt(".%s", domain);
        gfree(old);
    }
    if (lifespan > 0) {
        expiresAtt = "; expires=";
        when = time(0) + lifespan;
        if ((expires = ctime(&when)) != NULL) {
            expires[strlen(expires) - 1] = '\0';
        }

    } else {
        expiresAtt = "";
        expires = "";
    }
    /* 
       Allow multiple cookie headers. Even if the same name. Later definitions take precedence
     */
    secure = (flags & WEBS_COOKIE_SECURE) ? "; secure" : "";
    httponly = (flags & WEBS_COOKIE_HTTP) ?  "; httponly" : "";
    cookie = sfmt("%s=%s; path=%s%s%s%s%s%s%s", name, value, path, domainAtt, domain, expiresAtt, expires, secure, 
        httponly);
    if (wp->responseCookie) {
        old = wp->responseCookie;
        wp->responseCookie = sfmt("%s %s", wp->responseCookie, cookie);
        gfree(old);
        gfree(cookie);
    } else {
        wp->responseCookie = cookie;
    }
    gfree(domain);
}


static char *getToken(Webs *wp, char *delim)
{
    ringq_t     *buf;
    char        *token, *nextToken, *endToken;

    gassert(wp);
    buf = &wp->input;
    nextToken = (char*) buf->endp;

    for (token = (char*) buf->servp; (*token == ' ' || *token == '\t') && token < (char*) buf->endp; token++) {}

    if (delim == 0) {
        delim = " \t";
        if ((endToken = strpbrk(token, delim)) != 0) {
            nextToken = endToken + strspn(endToken, delim);
            *endToken = '\0';
        }
    } else {
        if ((endToken = strstr(token, delim)) != 0) {
            *endToken = '\0';
            /* Only eat one occurence of the delimiter */
            nextToken = endToken + strlen(delim);
        } else {
            nextToken = buf->endp;
        }
    }
    buf->servp = nextToken;
    return token;
}


int websGetBackground() 
{
    return websBackground;
}


void websSetBackground(int on) 
{
    websBackground = on;
}


int websGetDebug() 
{
    return websDebug;
}


void websSetDebug(int on) 
{
    websDebug = on;
}


static char *makeSessionID(Webs *wp)
{
    char        idBuf[64];
    static int  nextSession = 0;

    fmt(idBuf, sizeof(idBuf), "%08x%08x%d", PTOI(wp) + PTOI(wp->url), (int) time(0), nextSession++);
    return websMD5binary(idBuf, sizeof(idBuf), "::webs.session::");
}


WebsSession *websAllocSession(Webs *wp, char *id, time_t lifespan)
{
    WebsSession     *sp;

    if ((sp = galloc(sizeof(WebsSession))) == 0) {
        return 0;
    }
    sp->lifespan = lifespan;
    sp->expires = time(0) + lifespan;
    if (id == 0) {
        id = makeSessionID(wp);
    }
    sp->id = strdup(id);
    if ((sp->cache = symOpen(WEBS_SESSION_HASH)) == 0) {
        return 0;
    }
    return sp;
}


static void freeSession(WebsSession *sp)
{
    gfree(sp->id);
    gfree(sp);
}


WebsSession *websGetSession(Webs *wp, int create)
{
    socket_t    *sp;
    WebsKey       *sym;
    char      *id;
    
    if (!wp->session) {
        id = websGetSessionID(wp);
        if ((sym = symLookup(sessions, id)) == 0) {
            if (!create) {
                return 0;
            }
            if (sessionCount > BIT_LIMIT_SESSION_COUNT) {
                error("Too many sessions %d/%d", sessionCount, BIT_LIMIT_SESSION_COUNT);
                return 0;
            }
            sessionCount++;
            if ((wp->session = websAllocSession(wp, id, BIT_LIMIT_SESSION_LIFE)) == 0) {
                return 0;
            }
            if ((sym = symEnter(sessions, wp->session->id, valueSymbol(wp->session), 0)) == 0) {
                return 0;
            }
            wp->session = (WebsSession*) sym->content.value.symbol;
            sp = socketPtr(wp->sid);
            websSetCookie(wp, WEBS_SESSION, wp->session->id, "/", NULL, 0, sp->secure ? 1 : 0);
        } else {
            wp->session = (WebsSession*) sym->content.value.symbol;
        }
    }
    if (wp->session) {
        wp->session->expires = time(0) + wp->session->lifespan;
    }
    return wp->session;
}


char *websGetSessionID(Webs *wp)
{
    char  *cookies, *cookie;
    char  *cp, *value;
    ssize   len;
    int     quoted;

    if (wp->session) {
        return wp->session->id;
    }
    cookies = wp->cookie;
    for (cookie = cookies; cookie && (value = strstr(cookie, WEBS_SESSION)) != 0; cookie = value) {
        value += strlen(WEBS_SESSION);
        while (isspace((uchar) *value) || *value == '=') {
            value++;
        }
        quoted = 0;
        if (*value == '"') {
            value++;
            quoted++;
        }
        for (cp = value; *cp; cp++) {
            if (quoted) {
                if (*cp == '"' && cp[-1] != '\\') {
                    break;
                }
            } else {
                if ((*cp == ',' || *cp == ';') && cp[-1] != '\\') {
                    break;
                }
            }
        }
        len = cp - value;
        if ((cp = galloc(len + 1)) == 0) {
            return 0;
        }
        strncpy(cp, value, len);
        cp[len] = '\0';
        return cp;
    }
    return 0;
}


char *websGetSessionVar(Webs *wp, char *key, char *defaultValue)
{
    WebsSession     *sp;
    WebsKey         *sym;

    if ((sp = websGetSession(wp, 1)) != 0) {
        if ((sym = symLookup(sp->cache, key)) == 0) {
            return defaultValue;
        }
        return (char*) sym->content.value.symbol;
    }
    return 0;
}


void websRemoveSessionVar(Webs *wp, char *key)
{
    WebsSession     *sp;

    if ((sp = websGetSession(wp, 1)) != 0) {
        symDelete(sp->cache, key);
    }
}


int websSetSessionVar(Webs *wp, char *key, char *value)
{
    WebsSession  *sp;

    gassert(key && *key);

    if ((sp = websGetSession(wp, 1)) == 0) {
        return 0;
    }
    if (symEnter(sp->cache, key, valueString(value, VALUE_ALLOCATE), 0) == 0) {
        return -1;
    }
    return 0;
}


/*
    Get the next token from the input ringq. This eats leading spaces and tabs.
 */
static void pruneCache()
{
    WebsSession     *sp;
    time_t          when;
    WebsKey           *sym, *next;

    //  MOB - should limit size of session cache
    when = time(0);
    for (sym = symFirst(sessions); sym; sym = next) {
        next = symNext(sessions, sym);
        sp = (WebsSession*) sym->content.value.symbol;
        if (sp->expires <= when) {
            symDelete(sessions, sp->id);
            //  MOB - must make sure that no request is active using sp!!!
            //  Do we need acquire / release
            sessionCount--;
            freeSession(sp);
        }
    }
    greschedCallback(pruneId, WEBS_SESSION_PRUNE);
}

/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2012. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the Embedthis GoAhead open source license or you may acquire 
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.md distributed with
    this software for full details and other copyrights.

    Local variables:
    tab-width: 4
    c-basic-offset: 4
    End:
    vim: sw=4 ts=4 expandtab

    @end
 */
